<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RSA加解密签名用法]]></title>
    <url>%2F2017%2F08%2F11%2FRSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下js语言中， RSA加解密和签名加解密的实现。 分享两个库，都是用来加解密的，https://github.com/kjur/jsrsasign https://github.com/travist/jsencrypt由于jsrsasign库加密业务数据总是出现报错，之后就用了jsencrypt来实现了业务数据的加密，再通过jsrsasign来实现签名以及签名校验 首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码 ，实现加解密要以下几个步骤： （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 （3）乙方得到加密后的信息，用私钥解密。 12345678910111213141516171819export const encryptMethod = (bussinessParams: Object) =&gt; &#123; try &#123; //这部分是加密业务数据的方法 const encrypt = new JSEncrypt() encrypt.setPublicKey(publicKey) const encrypted = encrypt.encrypt(encodeURIComponent( JSON.stringify(bussinessParams))) console.log("公钥加密后，原文 : " + encrypted); return encrypted // 私钥解密 var decrypt = new JSEncrypt(); decrypt.setPrivateKey(privKey); console.log("公钥加密密文 : " + encrypted); var uncrypted = decrypt.decrypt(encrypted); console.log("私钥解密后，原文 : " + uncrypted); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 上面诉说的是业务数据的加密 我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名， 签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码 1234567891011121314151617export const sign = () =&gt; &#123; try &#123; const sig = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig.init(privateKey) sig.updateString(encrypted)//此处encrypted是加密的业务数据 const hSigVal = encodeURIComponent(sig.sign()) const sig1 = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig1.init(publicKey)//此处需要公钥去对签名进行校验 sig1.updateString(encrypted) const verified = sig1.verify(hSigVal) console.log("签名校验后结果 : " + verified); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 以下是签名的api文档：https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html签名校验的demo：https://kjur.github.io/jsrsasign/sample/sample-rsasign.html命令生成密钥文档：http://www.cnblogs.com/littleatp/p/5878763.html JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。 用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。 这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能 分段加密方法：123456789101112131415161718192021222324// The right encryption codeJSEncrypt.prototype.encryptLong = function(string) &#123; var k = this.getKey(); var maxLength = (((k.n.bitLength()+7)&gt;&gt;3)-11);//此处是算法来算出你的密钥可以支持的最大加密字符串长度 try &#123; var lt = ""; var ct = ""; if (string.length &gt; maxLength) &#123; lt = string.match(/.&#123;1,117&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.encrypt(entry); ct += t1 ; &#125;); return hex2b64(ct); &#125; var t = k.encrypt(string); var y = hex2b64(t); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 分段解密方法：1234567891011121314151617181920// The error decryption codeJSEncrypt.prototype.decryptLong = function(string) &#123; var k = this.getKey(); var maxLength = ((k.n.bitLength()+7)&gt;&gt;3); try &#123; var string = b64tohex(string); var ct = ""; if (string.length &gt; maxLength) &#123; var lt = string.match(/.&#123;1,128&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.decrypt(entry); ct += t1; &#125;); &#125; var y = k.decrypt(b64tohex(string)); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 此篇文章只是个人在使用这两个库中的使用的感受，jsencrypt可以加解密但是不存在签名方法， jsrsasign可以签名，但是使用过程中加密方法报错。初次写文章，不到之处还请轻喷！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[理解applyMiddleware和createStore之间的关系]]></title>
    <url>%2F2017%2F08%2F01%2F%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言不得不佩服redux的作者Dan Abramov，看完applyMiddleware的源码,我的感受就是：还有这种操作？与其说是理解applyMiddleware，不如说是理清createStore，applyMiddleware和一些中间件的关系，和为什么中间件都是export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}三层嵌套关系。 export default function applyMiddleware() { for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) { middlewares[_key] = arguments[_key]; } return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: function dispatch(action) { return _dispatch(action); } }; chain = middlewares.map(function (middleware) { return middleware(middlewareAPI); }); _dispatch = compose.apply(undefined, chain)(store.dispatch); return _extends({}, store, { dispatch: _dispatch }); }; }; } 精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）： 首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。 const store = createStore( reducer, undefined, enhancer ) 其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。 if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState); } 最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。 return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); //省略一万行 } } 至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。 菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。]]></content>
  </entry>
</search>
