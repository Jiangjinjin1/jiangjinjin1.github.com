<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>React高阶组件(HOC)入门</title>
      <link href="/2018/11/16/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC-%E5%85%A5%E9%97%A8/"/>
      <url>/2018/11/16/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;之前的文章<a href="https://segmentfault.com/a/1190000008814336" target="_blank" rel="noopener">React Mixins入门指南</a>介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a>在文章<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a>介绍了Mixin带来的一些问题,总结下来主要是以下几点:</p></blockquote><a id="more"></a><ul><li><p>破坏组件封装性: Mixin可能会引入不可见的属性。例如在渲染组件中使用Mixin方法，给组件带来了不可见的属性(props)和状态(state)。并且Mixin可能会相互依赖，相互耦合，不利于代码维护。</p></li><li><p>不同的Mixin中的方法可能会相互冲突</p></li><li><p>为了处理上述的问题，React官方推荐使用高阶组件(High Order Component)</p></li></ul><h1 id="高阶组件-HOC"><a href="#高阶组件-HOC" class="headerlink" title="高阶组件(HOC)"></a>高阶组件(HOC)</h1><hr><p>  &nbsp;&nbsp;&nbsp;&nbsp;刚开始学习高阶组件时，这个概念就透漏着高级的气味，看上去就像是一种先进的编程技术的一个深奥术语，毕竟名字里就有”高阶”这种字眼，实质上并不是如此。高阶组件的概念应该是来源于JavaScript的高阶函数:</p><blockquote><p><code>高阶函数就是接受函数作为输入或者输出的函数</code></p></blockquote><p>  这么看来<a href="https://segmentfault.com/a/1190000008193605" target="_blank" rel="noopener">柯里化</a>也是高阶函数了。React官方定义高阶组件的概念是:</p><blockquote><p><code>A higher-order component is a function that takes a component and returns a new component.</code></p></blockquote><p>  &nbsp;&nbsp;&nbsp;&nbsp;(参照翻译了React官方文档的<a href="https://github.com/MrErHu/React-Advanced-Guides-CN" target="_blank" rel="noopener">Advanced Guides</a>部分，官方的高阶组件中文文档戳<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FMrErHu%2FReact-Advanced-Guides-CN%2Fblob%2Fmaster%2Fdoc%2FHigher%2520Order%2520Components.md" target="_blank" rel="noopener">这里</a>)</p><p>  &nbsp;&nbsp;&nbsp;&nbsp;这么看来，高阶组件仅仅只是是一个接受组件组作输入并返回组件的函数。看上去并没有什么，那么高阶组件能为我们带来什么呢？首先看一下高阶组件是如何实现的，通常情况下，实现高阶组件的方式有以下两种:</p><ol><li>属性代理(Props Proxy)</li><li>反向继承(Inheritance Inversion)</li></ol><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;又是一个听起来很高大上的名词，实质上是通过包裹原来的组件来操作props，举个简单的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'React'</span>;</span><br><span class="line"><span class="comment">//高阶组件定义</span></span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//普通的组件</span><br><span class="line">class WrappedComponent extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//高阶组件使用</span><br><span class="line">export default HOC(WrappedComponent)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子非常简单，但足以说明问题。我们可以看见函数HOC返回了新的组件(WrapperComponent)，这个组件原封不动的返回作为参数的组件(也就是被包裹的组件:WrappedComponent)，并将传给它的参数(props)全部传递给被包裹的组件(WrappedComponent)。这么看起来好像并没有什么作用，其实属性代理的作用还是非常强大的。</p><h2 id="操作props"><a href="#操作props" class="headerlink" title="操作props"></a>操作props</h2><p>　　&nbsp;&nbsp;&nbsp;&nbsp;我们看到之前要传递给被包裹组件WrappedComponent的属性首先传递给了高阶组件返回的组件(WrapperComponent)，这样我们就获得了props的控制权(这也就是为什么这种方法叫做属性代理)。我们可以按照需要对传入的props进行增加、删除、修改(当然修改带来的风险需要你自己来控制)，举个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">                name: <span class="string">'HOC'</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent</span><br><span class="line">                &#123;...this.props&#125;</span><br><span class="line">                &#123;...newProps&#125;</span><br><span class="line">            /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。</p><h2 id="获得refs的引用"><a href="#获得refs的引用" class="headerlink" title="获得refs的引用"></a>获得<code>refs</code>的引用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(<code>ref</code>)，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'React'</span>;</span><br><span class="line">　</span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">wrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        storeRef(ref) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ref = ref;</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent</span><br><span class="line">                &#123;...this.props&#125;</span><br><span class="line">                ref = &#123;::this.storeRef&#125;</span><br><span class="line">            /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。</p><h2 id="抽象state"><a href="#抽象state" class="headerlink" title="抽象state"></a>抽象state</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变(关于不受控组件和受控组件戳<a href="https://github.com/MrErHu/React-Advanced-Guides-CN/blob/master/doc/Uncontrolled%20Components.md" target="_blank" rel="noopener">这里</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;input name="name" &#123;...this.props.name&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const HOC = (WrappedComponent) =&gt;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state = &#123;</span><br><span class="line">                name: '',</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            this.onNameChange = this.onNameChange.bind(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onNameChange(event) &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                name: event.target.value,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            const newProps = &#123;</span><br><span class="line">                name: &#123;</span><br><span class="line">                    value: this.state.name,</span><br><span class="line">                    onChange: this.onNameChange,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件.</p><h2 id="用其他元素包裹组件"><a href="#用其他元素包裹组件" class="headerlink" title="用其他元素包裹组件"></a>用其他元素包裹组件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过类似:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式将被包裹组件包裹起来，来实现布局或者是样式的目的。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在属性代理这种方式实现的高阶组件，以上述为例，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序是先WrapperComponent再WrappedComponent(执行ComponentWillUnmount的时间)。</p><h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:<code>super.render()</code>)，这也就是为什么叫做反向继承。</p><h2 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.isRender) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;甚至我们可以修改修改render的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子来源于《深入React技术栈》</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render();</span><br><span class="line">            <span class="keyword">let</span> newProps = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (elementsTree &amp;&amp; elementsTree.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">                newProps = &#123;<span class="attr">value</span>: <span class="string">'may the force be with you'</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps);</span><br><span class="line">            <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);</span><br><span class="line">            <span class="keyword">return</span> newElementsTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;input value=&#123;<span class="string">'Hello World'</span>&#125; /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HOC(WrappedComponent)</span><br><span class="line"><span class="comment">//实际显示的效果是input的值为"may the force be with you"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中我们将WrappedComponent中的input元素value值修改为:<code>may the force be with you。</code>我们可以看到前后elementTree的区别:<br>elementsTree:</p><p><img src="/images/react/react1.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;newElementsTree:</p><p><img src="/images/react/react2.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在反向继承中，我们可以做非常多的操作，修改state、props甚至是翻转Element Tree。反向继承有一个重要的点: <strong>反向继承不能保证完整的子组件树被解析</strong>，开始我对这个概念也不理解，后来在看了<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">React Components</a>, <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">Elements</a>, and <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">Instances</a>这篇文章之后对这个概念有了自己的一点体会。React Components, Elements, and Instances这篇文章主要明确了一下几个点:</p><p>&nbsp;&nbsp;&nbsp;&nbsp; + 元素(element)是一个是用DOM节点或者组件来描述屏幕显示的纯对象，元素可以在属性(props.children)中包含其他的元素，一旦创建就不会改变。我们通过<code>JSX</code>和<code>React.createClass</code>创建的都是元素。<br>&nbsp;&nbsp;&nbsp;&nbsp; + 组件(component)可以接受属性(props)作为输入，然后返回一个元素树(element tree)作为输出。有多种实现方式:Class或者函数(Function)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;所以，<strong>反向继承不能保证完整的子组件树被解析</strong>的意思的解析的元素树中包含了组件(函数类型或者Class类型)，就不能再操作组件的子组件了，这就是所谓的<strong>不能完全解析</strong>。举个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyFuncComponent = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class MyClassComponent extends Component&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    render()&#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;span&gt;Hello World&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">                &lt;MyFuncComponent /&gt;</span><br><span class="line">                &lt;MyClassComponent /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const HOC = (WrappedComponent) =&gt;</span></span><br><span class="line"><span class="regexp">    class extends WrappedComponent &#123;</span></span><br><span class="line"><span class="regexp">        render() &#123;</span></span><br><span class="line"><span class="regexp">            const elementsTree = super.render();</span></span><br><span class="line"><span class="regexp">            return elementsTree;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default HOC(WrappedComponent);</span></span><br></pre></td></tr></table></figure><p><img src="/images/react/react3.png"></p><p><img src="/images/react/react4.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以查看解析的元素树(element tree)，<code>div</code>下的<code>span</code>是可以被完全被解析的，但是<code>MyFuncComponent</code>和<code>MyClassComponent</code>都是组件类型的，其子组件就不能被完全解析了。</p><h2 id="操作props和state"><a href="#操作props和state" class="headerlink" title="操作props和state"></a>操作props和state</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在上面的图中我们可以看到，解析的元素树(element tree)中含有<code>props</code>和<code>state</code>(例子的组件中没有state),以及<code>ref</code>和<code>key</code>等值。因此，如果需要的话，我们不仅可以读取<code>props</code>和<code>state</code>,甚至可以修改增加、修改和删除。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，我们可能需要为高阶属性传入一些参数，那我们就可以通过柯里化的形式传入参数，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'React'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HOCFactoryFactory = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 可以做一些改变 params 的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;可以通过下面方式使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOCFactoryFactory(params)(WrappedComponent)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式是不是非常类似于<code>React-Redux</code>库中的<code>connect</code>函数，因为<code>connect</code>也是类似的一种高阶函数。反向继承不同于属性代理的调用顺序，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序也是先WrappedComponent再WrapperComponent(执行ComponentWillUnmount的时间)。</p><h2 id="HOC和Mixin的比较"><a href="#HOC和Mixin的比较" class="headerlink" title="HOC和Mixin的比较"></a>HOC和Mixin的比较</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;借用《深入React技术栈》一书中的图:</p><p><img src="/images/react/react5.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/2018/11/16/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/11/16/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-markdown是什么？"><a href="#1-markdown是什么？" class="headerlink" title="1. markdown是什么？"></a>1. markdown是什么？</h1><blockquote><p>Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。<br>Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。</p></blockquote><a id="more"></a><h1 id="2-markdown语法"><a href="#2-markdown语法" class="headerlink" title="2. markdown语法"></a>2. markdown语法</h1><h2 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h2><p>标题有两种形式：<br>(1) 第一种是用=或者-表示一级或者二级标题</p><blockquote><p>一级标题<br><code>======</code><br>二级标题<br><code>------</code></p></blockquote><p>效果如下：</p><blockquote><h1 id="一级标题down"><a href="#一级标题down" class="headerlink" title="一级标题down"></a>一级标题down</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>(2) 第二种就是#来表示1-6级标题，与HTML的h1-h6相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; #一级标题</span><br><span class="line">&gt; ##二级标题</span><br><span class="line">&gt; ###三级标题</span><br><span class="line">&gt; ####四级标题</span><br><span class="line">&gt; #####五级标题</span><br><span class="line">&gt; ######六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h2><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：</p><blockquote><p>>引用<br>  >>嵌套引用</p></blockquote><p>效果如下：</p><blockquote><p>引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h2 id="2-3-代码块"><a href="#2-3-代码块" class="headerlink" title="2.3 代码块"></a>2.3 代码块</h2><p>代码块可以在每行加上四个空格来表示代码区域，效果如：</p><blockquote><p>   function foo(){<br>         return;<br>   }</p></blockquote><p>或者在开始与结尾用表示一样可以，效果同上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt; <span class="keyword">return</span>;</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-符号"><a href="#2-4-符号" class="headerlink" title="2.4 ``符号"></a>2.4 ``符号</h2><p>``可以用来表示相对较小区域的代码内容，或者起到标记作用，如</p><blockquote><p>`标记`</p></blockquote><p>效果如下：</p><blockquote><p><code>标记</code></p></blockquote><h2 id="2-5-强调与斜体"><a href="#2-5-强调与斜体" class="headerlink" title="2.5 强调与斜体"></a>2.5 强调与斜体</h2><p>在强调内容两侧分别加上*或者_，如：</p><blockquote><p>*斜体，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果如下：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h2 id="2-6-有序列表与无序列表"><a href="#2-6-有序列表与无序列表" class="headerlink" title="2.6 有序列表与无序列表"></a>2.6 有序列表与无序列表</h2><p>使用*、+、或-标记无序列表，如：</p><blockquote><p>(+-) 第一项 (+-) 第二项<br>*(+-) 第三项</p></blockquote><p>效果如下：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>使用数字123加上.即是有序列表，如：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><p>效果如下：</p><blockquote><p>1.第一项<br>2.第二项<br>3.第三项</p></blockquote><h2 id="2-7-分割线"><a href="#2-7-分割线" class="headerlink" title="2.7 分割线"></a>2.7 分割线</h2><p>分割线最常使用就是三个或以上*，还可以使用-和_，如：</p><blockquote><p>我是分割线1<br>***<br>我是分割线2<br>———<br>我是分割线3<br>___</p></blockquote><p>效果如下：</p><p>我是分割线1</p><hr><h2 id="我是分割线2"><a href="#我是分割线2" class="headerlink" title="我是分割线2"></a>我是分割线2</h2><p>我是分割线3</p><hr><h2 id="2-8-链接"><a href="#2-8-链接" class="headerlink" title="2.8 链接"></a>2.8 链接</h2><p>链接由[]与()组成，[]中的指描述，()中跟链接地址，如：</p><blockquote><p>[百度](<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a>)</p></blockquote><p>效果如下：</p><blockquote><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a></p></blockquote><h2 id="2-9-图片引入"><a href="#2-9-图片引入" class="headerlink" title="2.9 图片引入"></a>2.9 图片引入</h2><blockquote><p>![图片](图片地址)</p></blockquote><p>效果如下</p><blockquote><p><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6h85RMsib6oGMKz0eibALsD1ricmicj6gUbUWAOs0C6Ynhf7Na6IBLyoWpHxTnHAZoAdznwicTf1Xaa61xdnEjV1QTg/132" alt="图片"></p></blockquote><p>2.9 表格<br>写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First Header | Second Header | Third Header</span><br><span class="line">------------ | ------------- | ------------</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br></pre></td></tr></table></figure><p>在 Markdown 中，可以制作表格，例如：</p><table><thead><tr><th>First Header</th><th>Second Header</th><th>Third Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>RSA加解密签名用法</title>
      <link href="/2017/08/11/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95/"/>
      <url>/2017/08/11/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下<code>js</code>语言中， RSA加解密和签名加解密的实现。</p><a id="more"></a><p>分享两个库，都是用来加解密的，<a href="https://github.com/kjur/jsrsasign" target="_blank" rel="noopener">https://github.com/kjur/jsrsasign</a> <a href="https://github.com/travist/jsencrypt" target="_blank" rel="noopener">https://github.com/travist/jsencrypt</a><br>由于<code>jsrsasign</code>库加密业务数据总是出现报错，之后就用了<code>jsencrypt</code>来实现了业务数据的加密，再通过<code>jsrsasign</code>来实现签名以及签名校验</p><p><code>首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码，实现加解密要以下几个步骤：　　（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。　　（2）甲方获取乙方的公钥，然后用它对信息加密。　　（3）乙方得到加密后的信息，用私钥解密。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> encryptMethod = <span class="function">(<span class="params">bussinessParams: <span class="built_in">Object</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这部分是加密业务数据的方法</span></span><br><span class="line">    <span class="keyword">const</span> encrypt = <span class="keyword">new</span> JSEncrypt()</span><br><span class="line">    encrypt.setPublicKey(publicKey)</span><br><span class="line">    <span class="keyword">const</span> encrypted = encrypt.encrypt(<span class="built_in">encodeURIComponent</span>(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(bussinessParams)))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密后，原文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line">    <span class="comment">// 私钥解密</span></span><br><span class="line">    <span class="keyword">var</span> decrypt = <span class="keyword">new</span> JSEncrypt();</span><br><span class="line">    decrypt.setPrivateKey(privKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密密文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">var</span> uncrypted = decrypt.decrypt(encrypted);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"私钥解密后，原文 : "</span> + uncrypted);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面诉说的是业务数据的加密</p><p><code>我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名，签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sign = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sig = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig.init(privateKey)</span><br><span class="line">    sig.updateString(encrypted)<span class="comment">//此处encrypted是加密的业务数据</span></span><br><span class="line">    <span class="keyword">const</span> hSigVal = <span class="built_in">encodeURIComponent</span>(sig.sign())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sig1 = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig1.init(publicKey)<span class="comment">//此处需要公钥去对签名进行校验</span></span><br><span class="line">    sig1.updateString(encrypted)</span><br><span class="line">    <span class="keyword">const</span> verified = sig1.verify(hSigVal)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"签名校验后结果 : "</span> + verified);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是签名的api文档：<a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html</a><br>签名校验的demo：<a href="https://kjur.github.io/jsrsasign/sample/sample-rsasign.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/sample/sample-rsasign.html</a><br>命令生成密钥文档：<a href="http://www.cnblogs.com/littleatp/p/5878763.html" target="_blank" rel="noopener">http://www.cnblogs.com/littleatp/p/5878763.html</a></p><p><code>JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能</code></p><p>分段加密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The right encryption code</span></span><br><span class="line">JSEncrypt.prototype.encryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = (((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>)<span class="number">-11</span>);<span class="comment">//此处是算法来算出你的密钥可以支持的最大加密字符串长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lt = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      lt = string.match(<span class="regexp">/.&#123;1,117&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.encrypt(entry);</span><br><span class="line">        ct += t1 ;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> hex2b64(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t = k.encrypt(string);</span><br><span class="line">    <span class="keyword">var</span> y = hex2b64(t);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>分段解密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error decryption code</span></span><br><span class="line">JSEncrypt.prototype.decryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = ((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> string = b64tohex(string);</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      <span class="keyword">var</span> lt = string.match(<span class="regexp">/.&#123;1,128&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.decrypt(entry);</span><br><span class="line">        ct += t1;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y = k.decrypt(b64tohex(string));</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此篇文章只是个人在使用这两个库中的使用的感受，<code>jsencrypt</code>可以加解密但是不存在签名方法， <code>jsrsasign</code>可以签名，但是使用过程中加密方法报错。<br>初次写文章，不到之处还请轻喷！！！</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>理解applyMiddleware和createStore之间的关系</title>
      <link href="/2017/08/01/%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2017/08/01/%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不得不佩服redux的作者<code>Dan Abramov</code>，看完<code>applyMiddleware</code>的源码,我的感受就是：还有这种操作？<br>与其说是理解applyMiddleware，不如说是理清<code>createStore</code>，<code>applyMiddleware</code>和一些中间件的关系，和为什么中间件都是<code>export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}</code>三层嵌套关系。  </p><a id="more"></a><pre><code class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>{  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) {    middlewares[_key] = <span class="built_in">arguments</span>[_key];  }  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);      <span class="keyword">var</span> _dispatch = store.dispatch;      <span class="keyword">var</span> chain = [];      <span class="keyword">var</span> middlewareAPI = {        <span class="attr">getState</span>: store.getState,        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>{          <span class="keyword">return</span> _dispatch(action);        }      };      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>{        <span class="keyword">return</span> middleware(middlewareAPI);      });      _dispatch = compose.apply(<span class="literal">undefined</span>, chain)(store.dispatch);      <span class="keyword">return</span> _extends({}, store, {        <span class="attr">dispatch</span>: _dispatch      });    };  };}</code></pre><p>精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：<br><img src="/images/createStore1.png"><br>enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数<br><img src="/images/applyMiddleware1.png"><br>两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）：  </p><p><code>首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。</code>  </p><pre><code class="javascript"><span class="keyword">const</span> store = createStore(    reducer,    <span class="literal">undefined</span>,    enhancer  )</code></pre><p><code>其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。</code>  </p><pre><code class="javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) {    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) {      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);    }    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);  }</code></pre><p><code>最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。</code></p><pre><code class="javascript"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);    <span class="comment">//省略一万行</span>  }}</code></pre><p>至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。<br><img src="/images/applyMiddleware2.png"></p><h4 id="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"><a href="#菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。" class="headerlink" title="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"></a>菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</h4><p>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
