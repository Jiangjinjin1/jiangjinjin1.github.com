<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react-native随笔]]></title>
    <url>%2F2019%2F02%2F14%2Freact-native%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[前言做了react-native也有两年了，平时遇到的注意点和坑，只是解决了，但是并没有记录，现在回想我都不记得我遇到哪些坑了，一脸懵逼当中23333.。。，还是动动手记录下，免得明年也懵逼😆 注意点、坑点、不常用不易记的 1、flex和flexGrow的区别：正常情况下，flex:1，和flexGrow: 1,都会在父元素下占满各自的空间，flex: 1时，一个view想设置height，同时高于父元素的空间，这样高度仍然是占满父元素并不会撑开。flexGrow: 1时，设置了height，不会受父元素空间限制。解释：flex只有一个值，且值为整数时，等价于 flex：X, 1, 0 ！！这才是最终答案，是根本原因。flex这个属性是flexGrow、flexShrink和flexBasis三个属性的缩写。详细布局片可以看这篇文章[http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS知识面试题]]></title>
    <url>%2F2019%2F01%2F07%2FJS%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、基础javascript篇1、类的创建和继承（1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。 下面来创建一个Animal类： 12345678910111213// 定义一个动物类function Animal (name) &#123; // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function()&#123; console.log(this.name + '正在睡觉！'); &#125;&#125;// 原型方法Animal.prototype.eat = function(food) &#123; console.log(this.name + '正在吃：' + food);&#125;; 这样就生成了一个Animal类，实力化生成对象后，有方法和属性。 （2）类的继承——原型链继承 1234567891011--原型链继承function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';//&amp;emsp;Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat('fish'));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。 特点：基于原型链，既是父类的实例，也是子类的实例 缺点：无法实现多继承 （3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 12345678910function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点：可以实现多继承 缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。 （4）实例继承和拷贝继承 实例继承：为父类实例添加新特性，作为子类实例返回 拷贝继承：拷贝父类元素上的属性和方法 上述两个实用性不强，不一一举例。 （5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456789101112function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点：可以继承实例属性/方法，也可以继承原型属性/方法 缺点：调用了两次父类构造函数，生成了两份实例 （6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性 1234567891011121314151617function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 较为推荐 2、说说前端中的事件流&emsp;&emsp;HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。&emsp;&emsp;什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。 事件捕获阶段 处于目标阶段 事件冒泡阶段 &emsp;&emsp;addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 IE只支持事件冒泡。 3、如何让事件先冒泡后捕获&emsp;&emsp;在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。 4、callee和caller的作用与区别递归我们可能用到一些函数调用自身，即递归。下面是一个计算阶乘的。 123function factorial(x) &#123; return x&lt;=1 ? 1 : x*factorial(x-1);&#125; 运行后发现它很好的完成了我们的要求。可是还是存在一个问题，万一哪天有人重构这个函数改了函数名呢？修改不方便甚至漏改。 arguments.callee 使用callee 避免hard code 函数名。 123function factorial(x) &#123; return x&lt;=1 ? 1 : x * arguments.callee(x-1);&#125; callee是arguments对象的一个属性，指向 arguments 对象的函数，即当前函数。在例子中是XX。 caller 函数对象的一个属性，指向调用当前函数的函数。比如 A() 调用 B()， 则在B()中 B.caller 指向A()。 1234567function B()&#123; console.log(B.caller);&#125; (function A()&#123; B()&#125;)() 显然，只有当函数被调用时，该属性才会有值。不过当函数被全局调用时，该属性为null。 callee和caller结合 我们刚才在函数B() 中使用了 B.caller 。跟上面递归一样，将来如果有人重构改了函数名呢？ 下面用刚才说的 arguments.callee 替换。 123function B()&#123; console.log(arguments.callee.caller);&#125; 到这是不是好多了。再执行A() ，发现跟刚才的输出一样。 5、给history的replaceState和pushState行为添加监听事件具体做法为： 123456789101112var _wr = function(type) &#123; var orig = history[type]; return function() &#123; var rv = orig.apply(this, arguments); var e = new Event(type); e.arguments = arguments; window.dispatchEvent(e); return rv; &#125;;&#125;; history.pushState = _wr('pushState'); history.replaceState = _wr('replaceState'); 这样就创建了2个全新的事件，事件名为pushState和replaceState，我们就可以在全局监听： 123456window.addEventListener('replaceState', function(e) &#123; console.log('THEY DID IT AGAIN! replaceState 111111');&#125;);window.addEventListener('pushState', function(e) &#123; console.log('THEY DID IT AGAIN! pushState 2222222');&#125;); 这样就可以监听到pushState和replaceState行为。 二、进阶javascript篇1、自己实现一个bind函数原理：通过apply或者call方法来实现。 (1)初始版本 123456789Function.prototype.bind = function (obj, arg) &#123; var context = this; var tmpArg = Array.prototype.slice.call(arguments, 1); return function(newArg) &#123; var newArgs = tmpArg.concat(Array.prototype.slice.call(newArg)) return context.apply(obj, newArgs) &#125;&#125; (2) 考虑到原型链为什么要考虑？因为在new 一个bind过生成的新函数的时候，必须的条件是要继承原函数的原型 1234567891011121314151617Function.prototype.bind = function (obj, arg) &#123; var context = this; var tmpArg = Array.prototype.slice.call(arguments, 1); var newBind = function(newArg) &#123; var newArgs = tmpArg.concat(Array.prototype.slice.call(newArg)) return context.apply(obj, newArgs) &#125; var F = function() &#123;&#125; F.prototype = context.prototype; //这里需要一个寄生组合继承 newBind.prototype = new F(); return newBind&#125; 2、Macrotasks 和 MicrotasksMacrotask 和 microtask 都是属于上述的异步任务中的一种，我们先看一下他们分别是哪些 API ： macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick, Promises, Object.observe(废弃), MutationObserver &emsp;&emsp;setTimeout 的 macrotask ,和 Promise 的 microtask 有什么不同呢？ 我们通过下面的代码来展现他们的不同点： 12345678910console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 在这里，setTimeout的延时为0，而Promise.resolve()也是返回一个被resolve了promise对象，即这里的then方法中的函数也是相当于异步的立即执行任务，那么他们到底是谁在前谁在后？ 我们看看最终的运行结果（node 7.7.3)： 12345"script start""script end""promise1""promise2""setTimeout" 这里的运行结果是Promise的立即返回的异步任务会优先于setTimeout延时为0的任务执行。 原因是任务队列分为 macrotasks 和 microtasks，而Promise中的then方法的函数会被推入 microtasks 队列，而setTimeout的任务会被推入 macrotasks 队列。在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microtasks 队列清空。 注：一般情况下，macrotask queues 我们会直接称为 task queues，只有 microtask queues 才会特别指明。 那么也就是说如果我的某个 microtask 任务又推入了一个任务进入 microtasks 队列，那么在主线程完成该任务之后，仍然会继续运行 microtasks 任务直到任务队列耗尽。 而事件循环每次只会入栈一个 macrotask ，主线程执行完该任务后又会先检查 microtasks 队列并完成里面的所有任务后再执行 macrotask 3、手写实现Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// myPromise function Promise(excutor) &#123; let _this = this; _this.status = 'pending'; _this.value = undefined; _this.reason = undefined; _this.onResolvedCallbacks = []; // 存放then成功的回调 _this.onRejectedCallbacks = []; // 存放then失败的回调 function resolve(val) &#123; if(_this.status === 'pending') &#123; _this.status = 'resolved'; _this.value = val; _this.onResolvedCallbacks.forEach(function(resolveFn) &#123; if(resolveFn) &#123; resolveFn() &#125; &#125;) &#125; &#125; function reject(reasonValue) &#123; if(_this.status === 'pending') &#123; _this.status = 'rejected'; _this.reason = reasonValue; _this.onRejectedCallbacks.forEach(function(rejectFn) &#123; if(rejectFn) &#123; rejectFn() &#125; &#125;) &#125; &#125; excutor(resolve, reject)&#125;Promise.prototype.then = function (onFulfilled, onRjected) &#123; //成功和失败默认不传给一个函数，解决了问题8 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123; return value; &#125; onRjected = typeof onRjected === 'function' ? onRjected : function (err) &#123; throw err; &#125; let _this = this; let promise2; //返回的promise if (_this.status === 'resolved') &#123; promise2 = new Promise(function (resolve, reject) &#123; // 当成功或者失败执行时有异常那么返回的promise应该处于失败状态 setTimeout(function () &#123;// 根据规范让那俩家伙异步执行 try &#123; let x = onFulfilled(_this.value);//这里解释过了 // 写一个方法统一处理问题1-7 resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;) &#125; if (_this.status === 'rejected') &#123; promise2 = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; let x = onRjected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;) &#125; if (_this.status === 'pending') &#123; promise2 = new Promise(function (resolve, reject) &#123; _this.onResolvedCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;); _this.onRejectedCallbacks.push(function () &#123; setTimeout(function () &#123; try &#123; let x = onRjected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;) &#125;); &#125;) &#125; return promise2;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; // 接受四个参数，新Promise、返回值，成功和失败的回调 // 有可能这里返回的x是别人的promise // 尽可能允许其他乱写 if (promise2 === x) &#123; //这里应该报一个类型错误，来解决问题4 return reject(new TypeError('循环引用了')) &#125; // 看x是不是一个promise,promise应该是一个对象 let called; // 表示是否调用过成功或者失败，用来解决问题7 //下面判断上一次then返回的是普通值还是函数，来解决问题1、2 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; // 可能是promise &#123;&#125;,看这个对象中是否有then方法，如果有then我就认为他是promise了 try &#123; let then = x.then;// 保存一下x的then方法 if (typeof then === 'function') &#123; // 成功 //这里的y也是官方规范，如果还是promise，可以当下一次的x使用 //用call方法修改指针为x，否则this指向window then.call(x, function (y) &#123; if (called) return //如果调用过就return掉 called = true // y可能还是一个promise，在去解析直到返回的是一个普通值 resolvePromise(promise2, y, resolve, reject)//递归调用，解决了问题6 &#125;, function (err) &#123; //失败 if (called) return called = true reject(err); &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; if (called) return called = true; reject(e); &#125; &#125; else &#123; // 说明是一个普通值1 resolve(x); // 表示成功了 &#125;&#125; 4、Function.proto(getPrototypeOf)是什么？获取一个对象的原型，在chrome中可以通过proto的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。 那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。 123Function.__proto__==Object.prototype //falseFunction.__proto__.__proto__==Object.prototype //trueFunction.__proto__==Function.prototype//true 我们发现Function的原型也是Function。 我们用图可以来明确这个关系： 此处借图于[https://juejin.im/post/5b44a485e51d4519945fb6b7] 5、观察者或订阅模式的简单实现12345678910111213141516171819function Events()&#123;this.on=function(eventName,callBack)&#123; if(!this.handles)&#123; this.handles=&#123;&#125;; &#125; if(!this.handles[eventName])&#123; this.handles[eventName]=[]; &#125; this.handles[eventName].push(callBack);&#125;this.emit=function(eventName,obj)&#123; if(this.handles[eventName])&#123; for(var i=0;o&lt;this.handles[eventName].length;i++)&#123; this.handles[eventName][i](obj); &#125; &#125;&#125;return this;&#125; 这样我们就定义了Events，现在我们可以开始来调用： 123456var events=new Events();events.on('say',function(name)&#123; console.log('Hello',nama)&#125;);events.emit('say','Jony yu');//结果就是通过emit调用之后，输出了Jony yu 6、装饰器（Decorators） 我们知道继承模式是丰富子元素“内涵”的一种重要方式，不管是继承接口还是子类继承基类。而装饰者模式可以在不改变继承关系的前提下，包装先有的模块，使其内涵更加丰富，并不会影响到原来的功能。与继承相比，更加的灵活 (1)、类方法的装饰器 下面来介绍一下用装饰器来修饰函数，首先来看一个例子： 123456789101112131415let temple;function log(target, key, descriptor) &#123; console.log(`$&#123;key&#125; was called!`); temple = target;&#125;class P &#123; @log foo() &#123; console.log('Do something'); &#125;&#125;const p = new P()p.foo()console.log(P.prototype === temple) //true 上述是实例方法foo中我们用log函数修饰，log函数接受三个参数，通过P.prototype === temple(target)可以判断，在类的实例函数的装饰器函数第一个参数为类的原型，第二个参数为函数名本身，第三个参数为该函数的描述属性。 具体总结如下，对于类的函数的装饰器函数，依次接受的参数为： target：如果修饰的是类的实例函数，那么target就是类的原型。如果修饰的是类的静态函数，那么target就是类本身。 key： 该函数的函数名。 descriptor：该函数的描述属性，比如 configurable、value、enumerable等。 从上述的例子中我们可以看到，用装饰器来修饰相应的类的函数十分方便： 1234@logfoo() &#123; ...&#125; (2)、类的装饰器 装饰函数也可以直接修饰类： 1234567891011121314let templefunction foo(target)&#123; console.log(target); temple = target&#125;@fooclass P&#123; constructor()&#123; &#125;&#125;const p = new P();temple === P //true 当装饰函数直接修饰类的时候，装饰函数接受唯一的参数，这个参数就是该被修饰类本身。上述的例子中，输出的target就是类P的本身。 此外，在修饰类的时候，如果装饰函数有返回值，该返回值会重新定义这个类，也就是说当装饰函数有返回值时，其实是生成了一个新类，该新类通过返回值来定义。 举例来说： 1234567891011121314151617function foo(target)&#123; return class extends target&#123; name = 'Jony'; sayHello()&#123; console.log("Hello "+ this.name) &#125; &#125;&#125;@fooclass P&#123; constructor()&#123; &#125;&#125;const p = new P();p.sayHello(); // 会输出Hello Jony 上面的例子可以看到，当装饰函数foo有返回值时，实际上P类已经被返回值所代表的新类所代替，因此P的实例p拥有sayHello方法。 (3)、类的属性的装饰器 下面我们来看类的属性的装饰器,装饰函数修饰类的属性时，在类实例化的时候调用属性的装饰函数，举例来说： 12345678910function foo(target,name)&#123; console.log("target is",target); console.log("name is",name)&#125;class P&#123; @foo name = 'Jony'&#125;const p = new P();//会依次输出 target is f P() name is Jony 这里对于类的属性的装饰器函数接受两个参数，对于静态属性而言，第一个参数是类本身，对于实例属性而言，第一个参数是类的原型，第二个参数是指属性的名字。 (4)、类函数参数的装饰器 接着来看类函数参数的装饰器，类函数的参数装饰器可以修饰类的构建函数中的参数，以及类中其他普通函数中的参数。该装饰器在类的方法被调用的时候执行，下面来看实例： 123456789101112function foo(target,key,index)&#123; console.log("target is",target); console.log("key is",key); console.log("index is",index)&#125;class P&#123; test(@foo a)&#123; &#125;&#125;const p = new P();p.test("Hello Jony")// 依次输出 f P() , test , 0 类函数参数的装饰器函数接受三个参数，依次为类本身，类中该被修饰的函数本身，以及被修饰的参数在参数列表中的索引值。上述的例子中，会依次输出 f P() 、test和0。再次明确一下修饰函数参数的装饰器函数中的参数含义： target： 类本身 key：该参数所在的函数的函数名 index： 该参数在函数参数列表中的索引值 从上面的Typescrit中在基类中常用的装饰器后，我们发现： 装饰器可以起到分离复杂逻辑的功能，且使用上极其简单方便。与继承相比，也更加灵活，可以从装饰类，到装饰类函数的参数，可以说武装到了“牙齿”。 三、http、html和浏览器篇1、http和httpshttps的SSL加密是在传输层实现的。 (1)http和https的基本概念 http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。 (2)http和https的区别？ http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。主要的区别如下： Https协议需要ca证书，费用较高。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 (3)https协议的工作原理 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤。 客户使用https url访问服务器，则要求web 服务器建立ssl链接。 web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。 客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 web服务器通过自己的私钥解密出会话密钥。 web服务器通过会话密钥加密与客户端之间的通信。 (4)https协议的优点 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 (5)https协议的缺点 https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。 https缓存不如http高效，会增加数据开销。 SSL证书也需要钱，功能越强大的证书费用越高。 SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。 2、http2.0首先补充一下，http和https的区别，相比于http,https是基于ssl加密的http协议简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。 提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0） 允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。 二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码 首部压缩 服务器端推送 3、一个图片url访问后直接下载怎样实现？请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。 下载的情况下： request1234561. x-oss-object-type: Normal2. x-oss-request-id: 598D5ED34F29D01FE2925F413. x-oss-storage-class: Standard 4、iframe是什么？有什么缺点？定义：iframe元素会创建包含另一个文档的内联框架提示：可以将提示文字放在之间，来提示某些不支持iframe的浏览器 缺点： 会阻塞主页面的onload事件 搜索引擎无法解读这种页面，不利于SEO（search engine optimization） 搜索引擎优化 iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。 5、Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。 6、Cookie如何防范XSS攻击XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。 secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。 结果应该是这样的：Set-Cookie=….. 7、viewport和移动端布局看了小姐姐的文章挺好的： 响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh） 四、CSS相关1、画一条0.5px的线 采用meta viewport的方式 采用 border-image的方式 采用transform: scale()的方式 2、link标签和import标签的区别 link属于html标签，而@import是css提供的 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的。 3、多行元素的文本省略号1234 display: -webkit-box-webkit-box-orient:vertical-web-line-clamp:3overflow:hidden]]></content>
      <categories>
        <category>面试题类目</category>
      </categories>
      <tags>
        <tag>面试题类目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC设计理念]]></title>
    <url>%2F2019%2F01%2F04%2FIOC%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[什么是 IoCIoC 的全称叫做 Inversion of Control，可翻译为为「控制反转」或「依赖倒置」，它主要包含了三个准则： 1、高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象 2、抽象不应该依赖于具体实现，具体实现应该依赖于抽象 3、面向接口编程 而不要面向实现编程 依赖注入 所谓的依赖注入，简单来说就是把高层模块所依赖的模块通过传参的方式把依赖「注入」到模块内部，上面的代码可以通过依赖注入的方式改造成如下方式： 12345678910111213141516171819202122232425262728293031// app.jsclass App &#123; constructor(options) &#123; this.options = options; this.router = options.router; this.track = options.track; this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.router.to('home'); this.track.tracking(); this.options.onReady(); &#125;); &#125;&#125;// index.jsimport App from 'path/to/App';import Router from './modules/Router';import Track from './modules/Track';new App(&#123; router: new Router(), track: new Track(), onReady() &#123; // do something here... &#125;,&#125;); 但是如果产品说再加个分享功能，肯定要再加个this.share = options.share,这明显不是我们所期望的。 看下面的代码: 12345678910111213141516171819class App &#123; static modules = [] constructor(options) &#123; this.options = options; this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.initModules(); this.options.onReady(this); &#125;); &#125; static use(module) &#123; Array.isArray(module) ? module.map(item =&gt; App.use(item)) : App.modules.push(module); &#125; initModules() &#123; App.modules.map(module =&gt; module.init &amp;&amp; typeof module.init == 'function' &amp;&amp; module.init(this)); &#125;&#125; 经过改造后 App 内已经没有「具体实现」了，看不到任何业务代码了，那么如何使用 App 来管理我们的依赖呢： 1234567891011121314151617181920212223242526272829303132333435// modules/Router.jsimport Router from 'path/to/Router';export default &#123; init(app) &#123; app.router = new Router(app.options.router); app.router.to('home'); &#125;&#125;;// modules/Track.jsimport Track from 'path/to/Track';export default &#123; init(app) &#123; app.track = new Track(app.options.track); app.track.tracking(); &#125;&#125;;// index.jsimport App from 'path/to/App';import Router from './modules/Router';import Track from './modules/Track';App.use([Router, Track]);new App(&#123; router: &#123; mode: 'history', &#125;, track: &#123; // ... &#125;, onReady(app) &#123; // app.options ... &#125;,&#125;); 这样通过注入到modules里初始化，将 App 的this传入modules注入的方法中，实现绑定到 App 的对象上 总结 App 模块此时应该称之为「容器」比较合适了，跟业务已经没有任何关系了，它仅仅只是提供了一些方法来辅助管理注入的依赖和控制模块如何执行。控制反转（Inversion of Control）是一种「思想」，依赖注入（Dependency Injection）则是这一思想的一种具体「实现方式」，而这里的 App 则是辅助依赖管理的一个「容器」。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的css reset]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%B8%B8%E7%94%A8%E7%9A%84css-reset%2F</url>
    <content type="text"><![CDATA[常用的css reset雅虎工程师提供的CSS初始化示例代码123456789101112131415body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125; .clearfix:after &#123;content: "."; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125; body&#123;font:12px"宋体","Arial Narrow",HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125; a&#123;color:#2d374b;text-decoration:none&#125; a:hover&#123;color:#cd0200;text-decoration:underline&#125; em&#123;font-style:normal&#125; li&#123;list-style:none&#125; img&#123;border:0;vertical-align:middle&#125; table&#123;border-collapse:collapse;border-spacing:0&#125; p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125; body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:"SimSun","宋体","Arial Narrow";&#125; ul,ol&#123;list-style-type:none;&#125; select,input,img,select&#123;vertical-align:middle;&#125; a&#123;text-decoration:none;&#125; a:link&#123;color:#009;&#125; a:visited&#123;color:#800080;&#125; a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5 tahoma, arial, \5b8b\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化123456789html &#123;overflow-y:scroll;&#125; body &#123;margin:0; padding:29px00; font:12px"\5B8B\4F53",sans-serif;background:#ffffff;&#125; div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125; table,td,tr,th&#123;font-size:12px;&#125; li&#123;list-style-type:none;&#125; img&#123;vertical-align:top;border:0;&#125; ol,ul &#123;list-style:none;&#125; h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125; address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; admin10000.com 的html模板，用于每次新开发页面使用。123456789101112131415161718&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn"&gt; &lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="Content-Language" content="zh-CN" /&gt; &lt;meta name="Author" content="网页作者" /&gt; &lt;meta name="Copyright" content="网站版权" /&gt; &lt;meta name="keywords" content="网站关键字" /&gt; &lt;meta name="description" content="网站描述" /&gt; &lt;link rel="Shortcut Icon" href="网站.ico图标路径" /&gt; &lt;link type="text/css" rel="stylesheet" href="CSS文件路径" /&gt; &lt;script type="text/javascript" src="JS文件路径"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS类</category>
      </categories>
      <tags>
        <tag>CSS类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue面试题]]></title>
    <url>%2F2018%2F11%2F29%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>面试题类目</category>
      </categories>
      <tags>
        <tag>面试题类目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react面试题]]></title>
    <url>%2F2018%2F11%2F29%2Freact%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、dispatch触发action，react视图更新过程 当我们dispatch 一个 action 的时候， 调用的其实是 store.dispatch，这个都没问题，store.dispatch 会去跑一遍所有注册在 createStore 中的 reducer， 找到对应的 type 更新数据，返回一个新的 state。 而我们的组件想拿到 store 的数据必须通过 `connect(mapStateToProps, mapDispatchToProps)(App)` 像这样，react-redux 中的 Connect 组件会在 `componengDidMount` 的时候去 调用 一个 `trySubscribe` 的方法，其内部调用 `store.subscrib`e 去订阅一个 handleChange 的方法。 所以当你 dispatch action 的时候，就会触发 Connect 组件中的方法， Connect 组件中也维护了一个叫做 `storeState` 的 state，每次拿到新的 sotre 就去调用 setState， 触发 render 函数， render 函数会根据你 connect 中传入的 mapStateToProps， mapDispatchToProps，包括可选参数 mergeProps， 去做一个 props 的合并动作， 最终在 Connect 组件内部 return 出来一个 `createElement(WrappedComponent,this.mergedProps)` 这样的东西，而 createElement 第二个参数就是你组件的 props， 那么每次 props 变了，就会驱动视图的更新。这就是 Redux 其中的中做原理。 2、redux中间件 中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。 常见的中间件： redux-logger：提供日志输出 redux-thunk：处理异步操作 redux-promise：处理异步操作，actionCreator的返回值是promise 3、redux有什么缺点 1.一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。2.当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 4、react组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为UI组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过React-Redux 提供connect方法联系起来。 具体使用可以参照如下链接：[http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html] 5、为什么虚拟dom会提高性能? 虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能 具体实现步骤如下： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 参考链接： [https://www.zhihu.com/question/29504639?sort=created] 6、diff算法?把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的key属性，方便比较。React 只会匹配相同 class 的 component（这里面的class指的是组件的名字）合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。 参考链接： [https//segmentfault.com/a/1190000000606216] 7、react性能优化方案 (1）重写shouldComponentUpdate来避免不必要的dom操作。 （2）使用 production 版本的react.js。 （3）使用key来帮助React识别列表中所有子组件的最小变化。 参考链接： [https://segmentfault.com/a/1190000006254212]]]></content>
      <categories>
        <category>面试题类目</category>
      </categories>
      <tags>
        <tag>面试题类目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中使用生成项目结构图tree]]></title>
    <url>%2F2018%2F11%2F29%2Fmac%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9B%BEtree%2F</url>
    <content type="text"><![CDATA[mac Mac 的话是没有自带tree命令的，但是我们可以通过homebrew（如果你不知道它的话，这是官网）安装： 12 brew install tree 然后等待安装完成后 12tree --version # 查看是否安装成功tree --help # 查看帮助 中文Api123456789101112131415161718192021-a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用"?"号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 Used 下面是我生成上面的结构所用的命令，大家可以参考下 1tree -I 'node_modules|dist|*.mp3|*.jpg' -f]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue入手及遇到的坑点]]></title>
    <url>%2F2018%2F11%2F29%2Fmpvue%E5%85%A5%E6%89%8B%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言对于未接触过小程序的我来说，想起手做个小程序还是要费点时间去学习，但是mpvue的出现让我提起了做小程序的兴趣。从而我的第一个小程序就这么从mpvue中摸爬滚打中开始了 mpvue mpvue是什么，是一个利用vue的runtime和compiler将vue类型文件的代码通过webpack打包转译成小程序的代码。 让我们先从如何获取一个mpvue脚手架开始起步吧 首先准备好node，然后在命令行中执行以下命令： 12345678910111213141516171819202122# 1. 先检查下 Node.js 是否安装成功$ node -vv8.9.0$ npm -v5.6.0# 2. 由于众所周知的原因，可以考虑切换源为 taobao 源$ npm set registry https://registry.npm.taobao.org/# 3. 全局安装 vue-cli# 一般是要 sudo 权限的$ npm install --global vue-cli@2.9# 4. 创建一个基于 mpvue-quickstart 模板的新项目# 新手一路回车选择默认就可以了$ vue init mpvue/mpvue-quickstart my-project# 5. 安装依赖，走你$ cd my-project$ npm install$ npm run dev 依次执行上面的命令，到最后安装好所以依赖，执行npm run dev这时候本地服务就启动了，项目目录中会多出个dist目录了。 上面是摘自: mpvue文档[http://mpvue.com/mpvue/quickstart/#3-mpvue] 剩下的不多说小伙伴们直接去官方文档看就好了，只介绍个起步，下面我们将开始讲述我mpvue的开发过程 mpvue开发的框架图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677├── ./README.md├── ./build│ ├── ./build/build.js│ ├── ./build/check-versions.js│ ├── ./build/dev-client.js│ ├── ./build/dev-server.js│ ├── ./build/devbuild.js│ ├── ./build/prod-server.js│ ├── ./build/utils.js│ ├── ./build/vue-loader.conf.js│ ├── ./build/webpack.base.conf.js│ ├── ./build/webpack.dev.conf.js│ ├── ./build/webpack.devprod.config.js│ ├── ./build/webpack.prod.conf.js│ └── ./build/webpack.prodserver.config.js├── ./config│ ├── ./config/dev.env.js│ ├── ./config/index.js│ └── ./config/prod.env.js├── ./index.html├── ./package-lock.json├── ./package.json├── ./project.config.json├── ./src│ ├── ./src/App.vue│ ├── ./src/app.json│ ├── ./src/main.js│ ├── ./src/components│ │ ├── ./src/components/addRecord.vue│ ├── ./src/config│ │ └── ./src/config/apiconfig│ │ └── ./src/config/apiconfig/config.js│ ├── ./src/fetchData│ │ ├── ./src/fetchData/fetchDiscover.js│ ├── ./src/http│ │ ├── ./src/http/api.js│ │ └── ./src/http/config.js│ ├── ./src/main.js│ ├── ./src/pages│ │ └── ./src/pages/searchlist│ │ ├── ./src/pages/searchlist/component│ │ │ ├── ./src/pages/searchlist/component/courts.vue│ │ │ ├── ./src/pages/searchlist/component/goodsType.vue│ │ │ ├── ./src/pages/searchlist/component/priceRange.vue│ │ │ └── ./src/pages/searchlist/component/sortView.vue│ │ ├── ./src/pages/searchlist/index.vue│ │ ├── ./src/pages/searchlist/main.js│ │ └── ./src/pages/searchlist/main.json│ ├── ./src/store│ │ ├── ./src/store/actions.js│ │ ├── ./src/store/getters.js│ │ ├── ./src/store/mutaions.js│ │ ├── ./src/store/mutation-type.js│ │ └── ./src/store/store.js│ └── ./src/utils│ ├── ./src/utils/data│ │ ├── ./src/utils/data/city.js│ │ ├── ./src/utils/data/discoverData.js│ │ ├── ./src/utils/data/handleUtils.js│ │ ├── ./src/utils/data/mincity.js│ │ └── ./src/utils/data/region.json│ ├── ./src/utils/style│ │ ├── ./src/utils/style/common.css│ │ └── ./src/utils/style/mixin.css│ └── ./src/utils/tipUtil│ └── ./src/utils/tipUtil/tips.js└── ./static ├── ./static/images │ ├── ./static/images/default_pic.png ├── ./static/iview │ ├── ./static/iview/action-sheet │ │ ├── ./static/iview/action-sheet/index.js │ │ ├── ./static/iview/action-sheet/index.json │ │ ├── ./static/iview/action-sheet/index.wxml │ │ └── ./static/iview/action-sheet/index.wxss └── ./static/weui └── ./static/weui/weui.css 上线流程图中我们先分析下结构，build和config目录是存放webpack配置文件的，有需要特殊配置的小伙伴自行修改配置即可。 剩下的的就是src和static目录，初期构建出来的项目并没有static目录，但是能知道它的作用存放静态文件的,具体后面讲。 index.html是作为解析mpvue入口html文件 project.config.json这个文件是用来设置小程序开发工具设置和appid的配置文件 再到src目录，components存放vue组件，config和http是封装请求方法的，utils是存放公共方法类文件的，pages是存放页面级文件的，每个page里有三个文件，分别是index.vue、main.js、main.json。 src里有三个文件，main.js、App.vue,这两个分别对应vue框架中的入口js文件和入口模板，还有个app.json这是小程序配置路由等信息的文件 解析上诉内容目录1、static目录的作用static是存放静态文件的，mpvue框架由于目前架构还不是很成熟，所以在页面中引入图片资源时将图片放到src目录下，打包到dist，引入图片是加载不出来的。所以目前就先将static目录以webpack的copy方法将static目录copy到dist目录，方便小程序的导入。同时我们想着如何引入三方的小程序UI库，这时候想到mpvue是将vue代码装成小程序代码，我们将小程序的UI组件引入到dist目录即可，供mpvue使用。要做到这点寿险将需要的UI组件存放到static对应的文件夹下。然后页面中如何使用呢，就需要到page目录下的main.json文件中配置了，看下面代码： 123456&#123; "navigationBarTitleText": "页面标题", "usingComponents": &#123; "i-icon": "../../static/iview/icon/index" &#125;&#125; 这样引入后在页面中直接使用组件即可：1&lt;i-icon class="iconUnfold" type="unfold" /&gt; 2、store如何使用store的使用和vue的使用是几乎一样的，不一样的在于它的引入及store存储的set和get需要改成小程序的方法。 1、在main.js入口文件时将store实例化对象引入到vue类的原型上1Vue.prototype.$store = store 这一点和vue是不一样的 2、vuex的set和get需要自己写，用到vuex-persistedstate库来实现set和get12345678910111213141516171819202122import createPersistedState from 'vuex-persistedstate'const store = new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; &#125;, plugins: [createPersistedState(&#123; // 配置白名单 paths: [ 'ztInfo', 'isLogin' ], storage: &#123; getItem: key =&gt; wx.getStorageSync(key), setItem: (key, value) =&gt; wx.setStorageSync(key, value), removeItem: key =&gt; &#123;&#125; &#125; &#125;)]&#125;) 做完这些，vuex就可以在项目中使用起来了 3、路由的使用 说到路由，有人讲到咋没看到vue-router啊，只能很抱歉的说一句目前还未很好的接入vue的路由，现阶段只能使用小程序的路由配置。 小程序的路由就需要用到src/app.json 1234567891011121314151617181920212223242526272829&#123; "pages": [ "pages/discover/main", // 页面路径 ], "window": &#123; // 全局窗口配置 "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#F73C31", "navigationBarTitleText": "展堂拍卖", "navigationBarTextStyle": "#ffffff" &#125;, "tabBar": &#123; // 底部导航切换 "color":"#000000", "selectedColor": "#f0220d", "list": [ &#123; "pagePath": "pages/discover/main", "text": "现场勘察", "iconPath": "static/images/nav_bottom2/nav_1.png", "selectedIconPath": "static/images/nav_bottom2/nav_1_on.png" &#125;, &#123; "pagePath": "pages/reservations/main", "text": "预约看样", "iconPath": "static/images/nav_bottom2/nav_2.png", "selectedIconPath": "static/images/nav_bottom2/nav_2_on.png" &#125; ] &#125;&#125; 4、project.config.json部分讲解123456789101112131415161718192021222324252627282930313233&#123; "description": "项目配置文件。", "setting": &#123; "urlCheck": true, "es6": false, // 是否将es6转成es5 "postcss": true, "minified": true, "newFeature": true &#125;, "miniprogramRoot": "dist/", // 小程序根目录 "compileType": "miniprogram", "appid": "wx86d90741d5d57774", // 小程序appid "projectname": "zhantang-fapai-wx-staff", // 项目名称 "libVersion": "2.3.2", // 使用基础调试库的版本 "condition": &#123; "search": &#123; "current": -1, "list": [] &#125;, "conversation": &#123; "current": -1, "list": [] &#125;, "game": &#123; "currentL": -1, "list": [] &#125;, "miniprogram": &#123; "current": -1, "list": [] &#125; &#125;&#125; 上诉注解的信息都可以在小程序工具中的详情中配置 讲述了这些基本上一个框架使用就可以开始了，剩下的接口封装，store实现就不详细讲了，接口封装我用的是flyio，store实现上面也讲了重要的点。 mpvue开发中遇到的坑点mpvue中vue的大部分功能都可以使用，但是有一些会存在问题。 vue中可以使用filter过滤，mpvue不行 vue中可以使用dom中methods方法调用获取返回值， 在mpvue中不行，可以考虑用computed计算实现 vue中常用的slot在mpvue也成了鸡肋 原生组件上不要使用v-if，例如map将会导致地图位置不刷新，水印，canvas组件将会不更新数据等 重点说下slot我遇到的坑，在vue中使用slot使用是对slot进行具名匹配，slot中的dom作用域是父组件的作用域，slot中组件同时可以继续嵌套。 那再mpvue中是什么个样子呢。。。我只想说12345678910111213141516```javascript&lt;select-city @onCityChange=&quot;onCityChange&quot; :selectAddress=&quot;selectAddress&quot;&gt; &lt;template slot=&quot;default&quot;&gt; &lt;section class=&quot;pickSection&quot;&gt; &lt;div class=&quot;picker&quot;&gt;&#123;&#123;selectAddress || &apos;地区&apos;&#125;&#125;&lt;/div&gt; &lt;i-icon class=&quot;iconUnfold&quot; type=&quot;unfold&quot; /&gt; &lt;/section&gt; &lt;/template&gt;&lt;/select-city&gt;```上面这块代码是mpvue中截取的，&lt;select-city/&gt;是个地址选择器组件，原先我要实现的功能是传个onCityChange方法进去并返回给我地址信息。然后将地址信息存到selectAddress变量里，再刷新到`&lt;div class=&quot;picker&quot;&gt;&#123;&#123;selectAddress || &apos;地区&apos;&#125;&#125;&lt;/div&gt;`这里，然而这么做了，然并卵 最后查阅资料后我才知道，mpvue中的slot只能传静态数据，且需要对slot具名，slot嵌套无效，更尴尬的是，slot中的作用域竟然是在子组件里。我有点蒙，然后就在父组件上传递了个selectAddress,然后才能获取地址信息。对于slot大家极力要求此功能完善下，目前为止还未实现 如果在小程序原生组件上例如map和canvas中使用v-if，mpvue在改变数据时会发现视图并未刷新。我采取的解决措施是将视图dom保留在文档流中，将组件定位到视图看不到的地方，符合条件再将之定位到需要的地方即可。 这里只阐述我遇到的坑~~~后续遇到将继续更新]]></content>
      <categories>
        <category>mpvue</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React高阶组件(HOC)入门]]></title>
    <url>%2F2018%2F11%2F16%2FReact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;之前的文章React Mixins入门指南介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。Dan Abramov在文章Mixins Considered Harmful介绍了Mixin带来的一些问题,总结下来主要是以下几点: 破坏组件封装性: Mixin可能会引入不可见的属性。例如在渲染组件中使用Mixin方法，给组件带来了不可见的属性(props)和状态(state)。并且Mixin可能会相互依赖，相互耦合，不利于代码维护。 不同的Mixin中的方法可能会相互冲突 为了处理上述的问题，React官方推荐使用高阶组件(High Order Component) 高阶组件(HOC) &nbsp;&nbsp;&nbsp;&nbsp;刚开始学习高阶组件时，这个概念就透漏着高级的气味，看上去就像是一种先进的编程技术的一个深奥术语，毕竟名字里就有”高阶”这种字眼，实质上并不是如此。高阶组件的概念应该是来源于JavaScript的高阶函数: 高阶函数就是接受函数作为输入或者输出的函数 这么看来柯里化也是高阶函数了。React官方定义高阶组件的概念是: A higher-order component is a function that takes a component and returns a new component. &nbsp;&nbsp;&nbsp;&nbsp;(参照翻译了React官方文档的Advanced Guides部分，官方的高阶组件中文文档戳这里) &nbsp;&nbsp;&nbsp;&nbsp;这么看来，高阶组件仅仅只是是一个接受组件组作输入并返回组件的函数。看上去并没有什么，那么高阶组件能为我们带来什么呢？首先看一下高阶组件是如何实现的，通常情况下，实现高阶组件的方式有以下两种: 属性代理(Props Proxy) 反向继承(Inheritance Inversion) 属性代理&nbsp;&nbsp;&nbsp;&nbsp;又是一个听起来很高大上的名词，实质上是通过包裹原来的组件来操作props，举个简单的例子: 123456789101112131415161718import React, &#123; Component &#125; from 'React';//高阶组件定义const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125;&#125;//普通的组件class WrappedComponent extends Component&#123; render()&#123; //.... &#125;&#125;//高阶组件使用export default HOC(WrappedComponent) &nbsp;&nbsp;&nbsp;&nbsp;上面的例子非常简单，但足以说明问题。我们可以看见函数HOC返回了新的组件(WrapperComponent)，这个组件原封不动的返回作为参数的组件(也就是被包裹的组件:WrappedComponent)，并将传给它的参数(props)全部传递给被包裹的组件(WrappedComponent)。这么看起来好像并没有什么作用，其实属性代理的作用还是非常强大的。 操作props &nbsp;&nbsp;&nbsp;&nbsp;我们看到之前要传递给被包裹组件WrappedComponent的属性首先传递给了高阶组件返回的组件(WrapperComponent)，这样我们就获得了props的控制权(这也就是为什么这种方法叫做属性代理)。我们可以按照需要对传入的props进行增加、删除、修改(当然修改带来的风险需要你自己来控制)，举个例子: 123456789101112const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component &#123; render() &#123; const newProps = &#123; name: 'HOC' &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。 获得refs的引用&nbsp;&nbsp;&nbsp;&nbsp;我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(ref)，例如: 1234567891011121314import React, &#123; Component &#125; from 'React'; const HOC = (WrappedComponent) =&gt; class wrapperComponent extends Component &#123; storeRef(ref) &#123; this.ref = ref; &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref = &#123;::this.storeRef&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。 抽象state&nbsp;&nbsp;&nbsp;&nbsp;属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变(关于不受控组件和受控组件戳这里) 123456789101112131415161718192021222324252627282930313233class WrappedComponent extends Component &#123; render() &#123; return &lt;input name="name" &#123;...this.props.name&#125; /&gt;; &#125;&#125;const HOC = (WrappedComponent) =&gt; class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: '', &#125;; this.onNameChange = this.onNameChange.bind(this); &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value, &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange, &#125;, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件. 用其他元素包裹组件&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过类似: 12345render()&#123; &lt;div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;这种方式将被包裹组件包裹起来，来实现布局或者是样式的目的。 &nbsp;&nbsp;&nbsp;&nbsp;在属性代理这种方式实现的高阶组件，以上述为例，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序是先WrapperComponent再WrappedComponent(执行ComponentWillUnmount的时间)。 反向继承&nbsp;&nbsp;&nbsp;&nbsp;反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指) 123456const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:super.render())，这也就是为什么叫做反向继承。 渲染劫持&nbsp;&nbsp;&nbsp;&nbsp;渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件: 12345678910const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; if (this.props.isRender) &#123; return super.render(); &#125; else &#123; return null; &#125; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;甚至我们可以修改修改render的结果: 123456789101112131415161718192021222324//例子来源于《深入React技术栈》const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); let newProps = &#123;&#125;; if (elementsTree &amp;&amp; elementsTree.type === 'input') &#123; newProps = &#123;value: 'may the force be with you'&#125;; &#125; const props = Object.assign(&#123;&#125;, elementsTree.props, newProps); const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children); return newElementsTree; &#125;&#125;class WrappedComponent extends Component&#123; render()&#123; return( &lt;input value=&#123;'Hello World'&#125; /&gt; ) &#125;&#125;export default HOC(WrappedComponent)//实际显示的效果是input的值为"may the force be with you" &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中我们将WrappedComponent中的input元素value值修改为:may the force be with you。我们可以看到前后elementTree的区别:elementsTree: &nbsp;&nbsp;&nbsp;&nbsp;newElementsTree: &nbsp;&nbsp;&nbsp;&nbsp;在反向继承中，我们可以做非常多的操作，修改state、props甚至是翻转Element Tree。反向继承有一个重要的点: 反向继承不能保证完整的子组件树被解析，开始我对这个概念也不理解，后来在看了React Components, Elements, and Instances这篇文章之后对这个概念有了自己的一点体会。React Components, Elements, and Instances这篇文章主要明确了一下几个点: &nbsp;&nbsp;&nbsp;&nbsp; + 元素(element)是一个是用DOM节点或者组件来描述屏幕显示的纯对象，元素可以在属性(props.children)中包含其他的元素，一旦创建就不会改变。我们通过JSX和React.createClass创建的都是元素。&nbsp;&nbsp;&nbsp;&nbsp; + 组件(component)可以接受属性(props)作为输入，然后返回一个元素树(element tree)作为输出。有多种实现方式:Class或者函数(Function)。 &nbsp;&nbsp;&nbsp;&nbsp;所以，反向继承不能保证完整的子组件树被解析的意思的解析的元素树中包含了组件(函数类型或者Class类型)，就不能再操作组件的子组件了，这就是所谓的不能完全解析。举个例子: 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';const MyFuncComponent = (props)=&gt;&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; );&#125;class MyClassComponent extends Component&#123; render()&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; ) &#125;&#125;class WrappedComponent extends Component&#123; render()&#123; return( &lt;div&gt; &lt;div&gt; &lt;span&gt;Hello World&lt;/span&gt; &lt;/div&gt; &lt;MyFuncComponent /&gt; &lt;MyClassComponent /&gt; &lt;/div&gt; ) &#125;&#125;const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); return elementsTree; &#125; &#125;export default HOC(WrappedComponent); &nbsp;&nbsp;&nbsp;&nbsp;我们可以查看解析的元素树(element tree)，div下的span是可以被完全被解析的，但是MyFuncComponent和MyClassComponent都是组件类型的，其子组件就不能被完全解析了。 操作props和state&nbsp;&nbsp;&nbsp;&nbsp;在上面的图中我们可以看到，解析的元素树(element tree)中含有props和state(例子的组件中没有state),以及ref和key等值。因此，如果需要的话，我们不仅可以读取props和state,甚至可以修改增加、修改和删除。 &nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，我们可能需要为高阶属性传入一些参数，那我们就可以通过柯里化的形式传入参数，例如: 123456789101112import React, &#123; Component &#125; from 'React';const HOCFactoryFactory = (...params) =&gt; &#123; // 可以做一些改变 params 的事 return (WrappedComponent) =&gt; &#123; return class HOC extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以通过下面方式使用: 1HOCFactoryFactory(params)(WrappedComponent) &nbsp;&nbsp;&nbsp;&nbsp;这种方式是不是非常类似于React-Redux库中的connect函数，因为connect也是类似的一种高阶函数。反向继承不同于属性代理的调用顺序，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序也是先WrappedComponent再WrapperComponent(执行ComponentWillUnmount的时间)。 HOC和Mixin的比较&nbsp;&nbsp;&nbsp;&nbsp;借用《深入React技术栈》一书中的图: &nbsp;&nbsp;&nbsp;&nbsp;高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础语法]]></title>
    <url>%2F2018%2F11%2F16%2Fmarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. markdown是什么？ Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. markdown语法2.1 标题标题有两种形式：(1) 第一种是用=或者-表示一级或者二级标题 一级标题======二级标题------ 效果如下： 一级标题down二级标题 (2) 第二种就是#来表示1-6级标题，与HTML的h1-h6相似。 123456&gt; #一级标题&gt; ##二级标题&gt; ###三级标题&gt; ####四级标题&gt; #####五级标题&gt; ######六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题2.2 引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： >引用 >>嵌套引用 效果如下： 引用 嵌套引用 2.3 代码块代码块可以在每行加上四个空格来表示代码区域，效果如： function foo(){ return; } 或者在开始与结尾用表示一样可以，效果同上： 123&gt; function foo()&#123;&gt; return;&gt; &#125; 2.4 ``符号``可以用来表示相对较小区域的代码内容，或者起到标记作用，如 `标记` 效果如下： 标记 2.5 强调与斜体在强调内容两侧分别加上*或者_，如： *斜体，_斜体_**粗体**，__粗体__ 效果如下： 斜体，斜体粗体，粗体 2.6 有序列表与无序列表使用*、+、或-标记无序列表，如： (+-) 第一项 (+-) 第二项*(+-) 第三项 效果如下： 第一项 第二项 第三项 使用数字123加上.即是有序列表，如： 第一项 第二项 第三项 效果如下： 1.第一项2.第二项3.第三项 2.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_，如： 我是分割线1***我是分割线2———我是分割线3___ 效果如下： 我是分割线1 我是分割线2我是分割线3 2.8 链接链接由[]与()组成，[]中的指描述，()中跟链接地址，如： [百度](https://www.baidu.com/) 效果如下： 百度 2.9 图片引入 ![图片](图片地址) 效果如下 2.9 表格写法 1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content Cell 在 Markdown 中，可以制作表格，例如： First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加解密签名用法]]></title>
    <url>%2F2017%2F08%2F11%2FRSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下js语言中， RSA加解密和签名加解密的实现。 分享两个库，都是用来加解密的，https://github.com/kjur/jsrsasign https://github.com/travist/jsencrypt由于jsrsasign库加密业务数据总是出现报错，之后就用了jsencrypt来实现了业务数据的加密，再通过jsrsasign来实现签名以及签名校验 首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码 ，实现加解密要以下几个步骤： （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 （3）乙方得到加密后的信息，用私钥解密。 12345678910111213141516171819export const encryptMethod = (bussinessParams: Object) =&gt; &#123; try &#123; //这部分是加密业务数据的方法 const encrypt = new JSEncrypt() encrypt.setPublicKey(publicKey) const encrypted = encrypt.encrypt(encodeURIComponent( JSON.stringify(bussinessParams))) console.log("公钥加密后，原文 : " + encrypted); return encrypted // 私钥解密 var decrypt = new JSEncrypt(); decrypt.setPrivateKey(privKey); console.log("公钥加密密文 : " + encrypted); var uncrypted = decrypt.decrypt(encrypted); console.log("私钥解密后，原文 : " + uncrypted); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 上面诉说的是业务数据的加密 我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名， 签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码 1234567891011121314151617export const sign = () =&gt; &#123; try &#123; const sig = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig.init(privateKey) sig.updateString(encrypted)//此处encrypted是加密的业务数据 const hSigVal = encodeURIComponent(sig.sign()) const sig1 = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig1.init(publicKey)//此处需要公钥去对签名进行校验 sig1.updateString(encrypted) const verified = sig1.verify(hSigVal) console.log("签名校验后结果 : " + verified); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 以下是签名的api文档：https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html签名校验的demo：https://kjur.github.io/jsrsasign/sample/sample-rsasign.html命令生成密钥文档：http://www.cnblogs.com/littleatp/p/5878763.html JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。 用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。 这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能 分段加密方法：123456789101112131415161718192021222324// The right encryption codeJSEncrypt.prototype.encryptLong = function(string) &#123; var k = this.getKey(); var maxLength = (((k.n.bitLength()+7)&gt;&gt;3)-11);//此处是算法来算出你的密钥可以支持的最大加密字符串长度 try &#123; var lt = ""; var ct = ""; if (string.length &gt; maxLength) &#123; lt = string.match(/.&#123;1,117&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.encrypt(entry); ct += t1 ; &#125;); return hex2b64(ct); &#125; var t = k.encrypt(string); var y = hex2b64(t); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 分段解密方法：1234567891011121314151617181920// The error decryption codeJSEncrypt.prototype.decryptLong = function(string) &#123; var k = this.getKey(); var maxLength = ((k.n.bitLength()+7)&gt;&gt;3); try &#123; var string = b64tohex(string); var ct = ""; if (string.length &gt; maxLength) &#123; var lt = string.match(/.&#123;1,128&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.decrypt(entry); ct += t1; &#125;); &#125; var y = k.decrypt(b64tohex(string)); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 此篇文章只是个人在使用这两个库中的使用的感受，jsencrypt可以加解密但是不存在签名方法， jsrsasign可以签名，但是使用过程中加密方法报错。初次写文章，不到之处还请轻喷！！！]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解applyMiddleware和createStore之间的关系]]></title>
    <url>%2F2017%2F08%2F01%2F%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言不得不佩服redux的作者Dan Abramov，看完applyMiddleware的源码,我的感受就是：还有这种操作？与其说是理解applyMiddleware，不如说是理清createStore，applyMiddleware和一些中间件的关系，和为什么中间件都是export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}三层嵌套关系。 export default function applyMiddleware() { for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) { middlewares[_key] = arguments[_key]; } return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: function dispatch(action) { return _dispatch(action); } }; chain = middlewares.map(function (middleware) { return middleware(middlewareAPI); }); _dispatch = compose.apply(undefined, chain)(store.dispatch); return _extends({}, store, { dispatch: _dispatch }); }; }; } 精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）： 首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。 const store = createStore( reducer, undefined, enhancer ) 其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。 if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState); } 最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。 return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); //省略一万行 } } 至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。 菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。]]></content>
      <categories>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
