<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React高阶组件(HOC)入门]]></title>
    <url>%2F2018%2F11%2F16%2FReact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;之前的文章React Mixins入门指南介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。Dan Abramov在文章Mixins Considered Harmful介绍了Mixin带来的一些问题,总结下来主要是以下几点: 破坏组件封装性: Mixin可能会引入不可见的属性。例如在渲染组件中使用Mixin方法，给组件带来了不可见的属性(props)和状态(state)。并且Mixin可能会相互依赖，相互耦合，不利于代码维护。 不同的Mixin中的方法可能会相互冲突 为了处理上述的问题，React官方推荐使用高阶组件(High Order Component) 高阶组件(HOC) &nbsp;&nbsp;&nbsp;&nbsp;刚开始学习高阶组件时，这个概念就透漏着高级的气味，看上去就像是一种先进的编程技术的一个深奥术语，毕竟名字里就有”高阶”这种字眼，实质上并不是如此。高阶组件的概念应该是来源于JavaScript的高阶函数: 高阶函数就是接受函数作为输入或者输出的函数 这么看来柯里化也是高阶函数了。React官方定义高阶组件的概念是: A higher-order component is a function that takes a component and returns a new component. &nbsp;&nbsp;&nbsp;&nbsp;(参照翻译了React官方文档的Advanced Guides部分，官方的高阶组件中文文档戳这里) &nbsp;&nbsp;&nbsp;&nbsp;这么看来，高阶组件仅仅只是是一个接受组件组作输入并返回组件的函数。看上去并没有什么，那么高阶组件能为我们带来什么呢？首先看一下高阶组件是如何实现的，通常情况下，实现高阶组件的方式有以下两种: 属性代理(Props Proxy) 反向继承(Inheritance Inversion) 属性代理&nbsp;&nbsp;&nbsp;&nbsp;又是一个听起来很高大上的名词，实质上是通过包裹原来的组件来操作props，举个简单的例子: 123456789101112131415161718import React, &#123; Component &#125; from 'React';//高阶组件定义const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125;&#125;//普通的组件class WrappedComponent extends Component&#123; render()&#123; //.... &#125;&#125;//高阶组件使用export default HOC(WrappedComponent) &nbsp;&nbsp;&nbsp;&nbsp;上面的例子非常简单，但足以说明问题。我们可以看见函数HOC返回了新的组件(WrapperComponent)，这个组件原封不动的返回作为参数的组件(也就是被包裹的组件:WrappedComponent)，并将传给它的参数(props)全部传递给被包裹的组件(WrappedComponent)。这么看起来好像并没有什么作用，其实属性代理的作用还是非常强大的。 操作props &nbsp;&nbsp;&nbsp;&nbsp;我们看到之前要传递给被包裹组件WrappedComponent的属性首先传递给了高阶组件返回的组件(WrapperComponent)，这样我们就获得了props的控制权(这也就是为什么这种方法叫做属性代理)。我们可以按照需要对传入的props进行增加、删除、修改(当然修改带来的风险需要你自己来控制)，举个例子: 123456789101112const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component &#123; render() &#123; const newProps = &#123; name: 'HOC' &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。 获得refs的引用&nbsp;&nbsp;&nbsp;&nbsp;我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(ref)，例如: 1234567891011121314import React, &#123; Component &#125; from 'React'; const HOC = (WrappedComponent) =&gt; class wrapperComponent extends Component &#123; storeRef(ref) &#123; this.ref = ref; &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref = &#123;::this.storeRef&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。 抽象state&nbsp;&nbsp;&nbsp;&nbsp;属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变(关于不受控组件和受控组件戳这里) 123456789101112131415161718192021222324252627282930313233class WrappedComponent extends Component &#123; render() &#123; return &lt;input name="name" &#123;...this.props.name&#125; /&gt;; &#125;&#125;const HOC = (WrappedComponent) =&gt; class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: '', &#125;; this.onNameChange = this.onNameChange.bind(this); &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value, &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange, &#125;, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件. 用其他元素包裹组件&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过类似: 12345render()&#123; &lt;div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;这种方式将被包裹组件包裹起来，来实现布局或者是样式的目的。 &nbsp;&nbsp;&nbsp;&nbsp;在属性代理这种方式实现的高阶组件，以上述为例，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序是先WrapperComponent再WrappedComponent(执行ComponentWillUnmount的时间)。 反向继承&nbsp;&nbsp;&nbsp;&nbsp;反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指) 123456const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:super.render())，这也就是为什么叫做反向继承。 渲染劫持&nbsp;&nbsp;&nbsp;&nbsp;渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件: 12345678910const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; if (this.props.isRender) &#123; return super.render(); &#125; else &#123; return null; &#125; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;甚至我们可以修改修改render的结果: 123456789101112131415161718192021222324//例子来源于《深入React技术栈》const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); let newProps = &#123;&#125;; if (elementsTree &amp;&amp; elementsTree.type === 'input') &#123; newProps = &#123;value: 'may the force be with you'&#125;; &#125; const props = Object.assign(&#123;&#125;, elementsTree.props, newProps); const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children); return newElementsTree; &#125;&#125;class WrappedComponent extends Component&#123; render()&#123; return( &lt;input value=&#123;'Hello World'&#125; /&gt; ) &#125;&#125;export default HOC(WrappedComponent)//实际显示的效果是input的值为"may the force be with you" &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中我们将WrappedComponent中的input元素value值修改为:may the force be with you。我们可以看到前后elementTree的区别:elementsTree: &nbsp;&nbsp;&nbsp;&nbsp;newElementsTree: &nbsp;&nbsp;&nbsp;&nbsp;在反向继承中，我们可以做非常多的操作，修改state、props甚至是翻转Element Tree。反向继承有一个重要的点: 反向继承不能保证完整的子组件树被解析，开始我对这个概念也不理解，后来在看了React Components, Elements, and Instances这篇文章之后对这个概念有了自己的一点体会。React Components, Elements, and Instances这篇文章主要明确了一下几个点: &nbsp;&nbsp;&nbsp;&nbsp; + 元素(element)是一个是用DOM节点或者组件来描述屏幕显示的纯对象，元素可以在属性(props.children)中包含其他的元素，一旦创建就不会改变。我们通过JSX和React.createClass创建的都是元素。&nbsp;&nbsp;&nbsp;&nbsp; + 组件(component)可以接受属性(props)作为输入，然后返回一个元素树(element tree)作为输出。有多种实现方式:Class或者函数(Function)。 &nbsp;&nbsp;&nbsp;&nbsp;所以，反向继承不能保证完整的子组件树被解析的意思的解析的元素树中包含了组件(函数类型或者Class类型)，就不能再操作组件的子组件了，这就是所谓的不能完全解析。举个例子: 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';const MyFuncComponent = (props)=&gt;&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; );&#125;class MyClassComponent extends Component&#123; render()&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; ) &#125;&#125;class WrappedComponent extends Component&#123; render()&#123; return( &lt;div&gt; &lt;div&gt; &lt;span&gt;Hello World&lt;/span&gt; &lt;/div&gt; &lt;MyFuncComponent /&gt; &lt;MyClassComponent /&gt; &lt;/div&gt; ) &#125;&#125;const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); return elementsTree; &#125; &#125;export default HOC(WrappedComponent); &nbsp;&nbsp;&nbsp;&nbsp;我们可以查看解析的元素树(element tree)，div下的span是可以被完全被解析的，但是MyFuncComponent和MyClassComponent都是组件类型的，其子组件就不能被完全解析了。 操作props和state&nbsp;&nbsp;&nbsp;&nbsp;在上面的图中我们可以看到，解析的元素树(element tree)中含有props和state(例子的组件中没有state),以及ref和key等值。因此，如果需要的话，我们不仅可以读取props和state,甚至可以修改增加、修改和删除。 &nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，我们可能需要为高阶属性传入一些参数，那我们就可以通过柯里化的形式传入参数，例如: 123456789101112import React, &#123; Component &#125; from 'React';const HOCFactoryFactory = (...params) =&gt; &#123; // 可以做一些改变 params 的事 return (WrappedComponent) =&gt; &#123; return class HOC extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以通过下面方式使用: 1HOCFactoryFactory(params)(WrappedComponent) &nbsp;&nbsp;&nbsp;&nbsp;这种方式是不是非常类似于React-Redux库中的connect函数，因为connect也是类似的一种高阶函数。反向继承不同于属性代理的调用顺序，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序也是先WrappedComponent再WrapperComponent(执行ComponentWillUnmount的时间)。 HOC和Mixin的比较&nbsp;&nbsp;&nbsp;&nbsp;借用《深入React技术栈》一书中的图: &nbsp;&nbsp;&nbsp;&nbsp;高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown基础语法]]></title>
    <url>%2F2018%2F11%2F16%2Fmarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. markdown是什么？ Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. markdown语法2.1 标题标题有两种形式：(1) 第一种是用=或者-表示一级或者二级标题 一级标题======二级标题------ 效果如下： 一级标题down二级标题 (2) 第二种就是#来表示1-6级标题，与HTML的h1-h6相似。 123456&gt; #一级标题&gt; ##二级标题&gt; ###三级标题&gt; ####四级标题&gt; #####五级标题&gt; ######六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题2.2 引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： >引用 >>嵌套引用 效果如下： 引用 嵌套引用 2.3 代码块代码块可以在每行加上四个空格来表示代码区域，效果如： function foo(){ return; } 或者在开始与结尾用表示一样可以，效果同上： 123&gt; function foo()&#123;&gt; return;&gt; &#125; 2.4 ``符号``可以用来表示相对较小区域的代码内容，或者起到标记作用，如 `标记` 效果如下： 标记 2.5 强调与斜体在强调内容两侧分别加上*或者_，如： *斜体，_斜体_**粗体**，__粗体__ 效果如下： 斜体，斜体粗体，粗体 2.6 有序列表与无序列表使用*、+、或-标记无序列表，如： (+-) 第一项 (+-) 第二项*(+-) 第三项 效果如下： 第一项 第二项 第三项 使用数字123加上.即是有序列表，如： 第一项 第二项 第三项 效果如下： 1.第一项2.第二项3.第三项 2.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_，如： 我是分割线1***我是分割线2———我是分割线3___ 效果如下： 我是分割线1 我是分割线2我是分割线3 2.8 链接链接由[]与()组成，[]中的指描述，()中跟链接地址，如： [百度](https://www.baidu.com/) 效果如下： 百度 2.9 图片引入 ![图片](图片地址) 效果如下 2.9 表格写法 1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content Cell 在 Markdown 中，可以制作表格，例如： First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA加解密签名用法]]></title>
    <url>%2F2017%2F08%2F11%2FRSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下js语言中， RSA加解密和签名加解密的实现。 分享两个库，都是用来加解密的，https://github.com/kjur/jsrsasign https://github.com/travist/jsencrypt由于jsrsasign库加密业务数据总是出现报错，之后就用了jsencrypt来实现了业务数据的加密，再通过jsrsasign来实现签名以及签名校验 首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码 ，实现加解密要以下几个步骤： （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 （3）乙方得到加密后的信息，用私钥解密。 12345678910111213141516171819export const encryptMethod = (bussinessParams: Object) =&gt; &#123; try &#123; //这部分是加密业务数据的方法 const encrypt = new JSEncrypt() encrypt.setPublicKey(publicKey) const encrypted = encrypt.encrypt(encodeURIComponent( JSON.stringify(bussinessParams))) console.log("公钥加密后，原文 : " + encrypted); return encrypted // 私钥解密 var decrypt = new JSEncrypt(); decrypt.setPrivateKey(privKey); console.log("公钥加密密文 : " + encrypted); var uncrypted = decrypt.decrypt(encrypted); console.log("私钥解密后，原文 : " + uncrypted); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 上面诉说的是业务数据的加密 我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名， 签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码 1234567891011121314151617export const sign = () =&gt; &#123; try &#123; const sig = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig.init(privateKey) sig.updateString(encrypted)//此处encrypted是加密的业务数据 const hSigVal = encodeURIComponent(sig.sign()) const sig1 = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig1.init(publicKey)//此处需要公钥去对签名进行校验 sig1.updateString(encrypted) const verified = sig1.verify(hSigVal) console.log("签名校验后结果 : " + verified); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 以下是签名的api文档：https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html签名校验的demo：https://kjur.github.io/jsrsasign/sample/sample-rsasign.html命令生成密钥文档：http://www.cnblogs.com/littleatp/p/5878763.html JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。 用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。 这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能 分段加密方法：123456789101112131415161718192021222324// The right encryption codeJSEncrypt.prototype.encryptLong = function(string) &#123; var k = this.getKey(); var maxLength = (((k.n.bitLength()+7)&gt;&gt;3)-11);//此处是算法来算出你的密钥可以支持的最大加密字符串长度 try &#123; var lt = ""; var ct = ""; if (string.length &gt; maxLength) &#123; lt = string.match(/.&#123;1,117&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.encrypt(entry); ct += t1 ; &#125;); return hex2b64(ct); &#125; var t = k.encrypt(string); var y = hex2b64(t); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 分段解密方法：1234567891011121314151617181920// The error decryption codeJSEncrypt.prototype.decryptLong = function(string) &#123; var k = this.getKey(); var maxLength = ((k.n.bitLength()+7)&gt;&gt;3); try &#123; var string = b64tohex(string); var ct = ""; if (string.length &gt; maxLength) &#123; var lt = string.match(/.&#123;1,128&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.decrypt(entry); ct += t1; &#125;); &#125; var y = k.decrypt(b64tohex(string)); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 此篇文章只是个人在使用这两个库中的使用的感受，jsencrypt可以加解密但是不存在签名方法， jsrsasign可以签名，但是使用过程中加密方法报错。初次写文章，不到之处还请轻喷！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[理解applyMiddleware和createStore之间的关系]]></title>
    <url>%2F2017%2F08%2F01%2F%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言不得不佩服redux的作者Dan Abramov，看完applyMiddleware的源码,我的感受就是：还有这种操作？与其说是理解applyMiddleware，不如说是理清createStore，applyMiddleware和一些中间件的关系，和为什么中间件都是export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}三层嵌套关系。 export default function applyMiddleware() { for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) { middlewares[_key] = arguments[_key]; } return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: function dispatch(action) { return _dispatch(action); } }; chain = middlewares.map(function (middleware) { return middleware(middlewareAPI); }); _dispatch = compose.apply(undefined, chain)(store.dispatch); return _extends({}, store, { dispatch: _dispatch }); }; }; } 精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）： 首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。 const store = createStore( reducer, undefined, enhancer ) 其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。 if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState); } 最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。 return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); //省略一万行 } } 至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。 菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。]]></content>
  </entry>
</search>
