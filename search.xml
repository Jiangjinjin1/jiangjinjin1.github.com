<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用的css reset]]></title>
    <url>%2F2018%2F12%2F12%2F%E5%B8%B8%E7%94%A8%E7%9A%84css-reset%2F</url>
    <content type="text"><![CDATA[常用的css reset雅虎工程师提供的CSS初始化示例代码123456789101112131415body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125; .clearfix:after &#123;content: "."; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 腾讯官网 样式初始化123456789body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select&#123;margin:0;padding:0&#125; body&#123;font:12px"宋体","Arial Narrow",HELVETICA;background:#fff;-webkit-text-size-adjust:100%;&#125; a&#123;color:#2d374b;text-decoration:none&#125; a:hover&#123;color:#cd0200;text-decoration:underline&#125; em&#123;font-style:normal&#125; li&#123;list-style:none&#125; img&#123;border:0;vertical-align:middle&#125; table&#123;border-collapse:collapse;border-spacing:0&#125; p&#123;word-wrap:break-word&#125; 新浪官网 样式初始化12345678910body,ul,ol,li,p,h1,h2,h3,h4,h5,h6,form,fieldset,table,td,img,div&#123;margin:0;padding:0;border:0;&#125; body&#123;background:#fff;color:#333;font-size:12px; margin-top:5px;font-family:"SimSun","宋体","Arial Narrow";&#125; ul,ol&#123;list-style-type:none;&#125; select,input,img,select&#123;vertical-align:middle;&#125; a&#123;text-decoration:none;&#125; a:link&#123;color:#009;&#125; a:visited&#123;color:#800080;&#125; a:hover,a:active,a:focus&#123;color:#c00;text-decoration:underline;&#125; 淘宝官网 样式初始化123456789101112131415body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125; body, button, input, select, textarea &#123; font:12px/1.5 tahoma, arial, \5b8b\4f53; &#125; h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125; address, cite, dfn, em, var &#123; font-style:normal; &#125; code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125; small&#123; font-size:12px; &#125; ul, ol &#123; list-style:none; &#125; a &#123; text-decoration:none; &#125; a:hover &#123; text-decoration:underline; &#125; sup &#123; vertical-align:text-top; &#125; sub&#123; vertical-align:text-bottom; &#125; legend &#123; color:#000; &#125; fieldset, img &#123; border:0; &#125; button, input, select, textarea &#123; font-size:100%; &#125; table &#123; border-collapse:collapse; border-spacing:0; &#125; 网易官网 样式初始化123456789html &#123;overflow-y:scroll;&#125; body &#123;margin:0; padding:29px00; font:12px"\5B8B\4F53",sans-serif;background:#ffffff;&#125; div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125; table,td,tr,th&#123;font-size:12px;&#125; li&#123;list-style-type:none;&#125; img&#123;vertical-align:top;border:0;&#125; ol,ul &#123;list-style:none;&#125; h1,h2,h3,h4,h5,h6&#123;font-size:12px; font-weight:normal;&#125; address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125; admin10000.com 的html模板，用于每次新开发页面使用。123456789101112131415161718&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn"&gt; &lt;head&gt; &lt;title&gt;网站标题 - Admin10000.com &lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta http-equiv="Content-Language" content="zh-CN" /&gt; &lt;meta name="Author" content="网页作者" /&gt; &lt;meta name="Copyright" content="网站版权" /&gt; &lt;meta name="keywords" content="网站关键字" /&gt; &lt;meta name="description" content="网站描述" /&gt; &lt;link rel="Shortcut Icon" href="网站.ico图标路径" /&gt; &lt;link type="text/css" rel="stylesheet" href="CSS文件路径" /&gt; &lt;script type="text/javascript" src="JS文件路径"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS类</category>
      </categories>
      <tags>
        <tag>CSS类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue面试题]]></title>
    <url>%2F2018%2F11%2F29%2Fvue%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>面试题类目</category>
      </categories>
      <tags>
        <tag>面试题类目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react面试题]]></title>
    <url>%2F2018%2F11%2F29%2Freact%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、dispatch触发action，react视图更新过程 答: 当我们dispatch 一个 action 的时候， 调用的其实是 store.dispatch，这个都没问题，store.dispatch 会去跑一遍所有注册在 createStore 中的 reducer， 找到对应的 type 更新数据，返回一个新的 state。 而我们的组件想拿到 store 的数据必须通过 connect(mapStateToProps, mapDispatchToProps)(App) 像这样，react-redux 中的 Connect 组件会在 componengDidMount 的时候去 调用 一个 trySubscribe 的方法，其内部调用 store.subscribe 去订阅一个 handleChange 的方法。 所以当你 dispatch action 的时候，就会触发 Connect 组件中的方法， Connect 组件中也维护了一个叫做 storeState 的 state，每次拿到新的 sotre 就去调用 setState， 触发 render 函数， render 函数会根据你 connect 中传入的 mapStateToProps， mapDispatchToProps，包括可选参数 mergeProps， 去做一个 props 的合并动作， 最终在 Connect 组件内部 return 出来一个 createElement(WrappedComponent,this.mergedProps) 这样的东西，而 createElement 第二个参数就是你组件的 props， 那么每次 props 变了，就会驱动视图的更新。这就是 Redux 其中的中做原理。]]></content>
      <categories>
        <category>面试题类目</category>
      </categories>
      <tags>
        <tag>面试题类目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中使用生成项目结构图tree]]></title>
    <url>%2F2018%2F11%2F29%2Fmac%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9B%BEtree%2F</url>
    <content type="text"><![CDATA[mac Mac 的话是没有自带tree命令的，但是我们可以通过homebrew（如果你不知道它的话，这是官网）安装： 12 brew install tree 然后等待安装完成后 12tree --version # 查看是否安装成功tree --help # 查看帮助 中文Api123456789101112131415161718192021-a 显示所有文件和目录。-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。-C 在文件和目录清单加上色彩，便于区分各种类型。-d 显示目录名称而非内容。-D 列出文件或目录的更改时间。-f 在每个文件或目录之前，显示完整的相对路径名称。-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号。-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。-i 不以阶梯状列出文件或目录名称。-I 不显示符合范本样式的文件或目录名称。-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。-n 不在文件和目录清单加上色彩。-N 直接列出文件和目录名称，包括控制字符。-p 列出权限标示。-P 只显示符合范本样式的文件或目录名称。-q 用"?"号取代控制字符，列出文件和目录名称。-s 列出文件或目录大小。-t 用文件和目录的更改时间排序。-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 Used 下面是我生成上面的结构所用的命令，大家可以参考下 1tree -I 'node_modules|dist|*.mp3|*.jpg' -f]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue入手及遇到的坑点]]></title>
    <url>%2F2018%2F11%2F29%2Fmpvue%E5%85%A5%E6%89%8B%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言对于未接触过小程序的我来说，想起手做个小程序还是要费点时间去学习，但是mpvue的出现让我提起了做小程序的兴趣。从而我的第一个小程序就这么从mpvue中摸爬滚打中开始了 mpvue mpvue是什么，是一个利用vue的runtime和compiler将vue类型文件的代码通过webpack打包转译成小程序的代码。 让我们先从如何获取一个mpvue脚手架开始起步吧 首先准备好node，然后在命令行中执行以下命令： 12345678910111213141516171819202122# 1. 先检查下 Node.js 是否安装成功$ node -vv8.9.0$ npm -v5.6.0# 2. 由于众所周知的原因，可以考虑切换源为 taobao 源$ npm set registry https://registry.npm.taobao.org/# 3. 全局安装 vue-cli# 一般是要 sudo 权限的$ npm install --global vue-cli@2.9# 4. 创建一个基于 mpvue-quickstart 模板的新项目# 新手一路回车选择默认就可以了$ vue init mpvue/mpvue-quickstart my-project# 5. 安装依赖，走你$ cd my-project$ npm install$ npm run dev 依次执行上面的命令，到最后安装好所以依赖，执行npm run dev这时候本地服务就启动了，项目目录中会多出个dist目录了。 上面是摘自: mpvue文档[http://mpvue.com/mpvue/quickstart/#3-mpvue] 剩下的不多说小伙伴们直接去官方文档看就好了，只介绍个起步，下面我们将开始讲述我mpvue的开发过程 mpvue开发的框架图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677├── ./README.md├── ./build│ ├── ./build/build.js│ ├── ./build/check-versions.js│ ├── ./build/dev-client.js│ ├── ./build/dev-server.js│ ├── ./build/devbuild.js│ ├── ./build/prod-server.js│ ├── ./build/utils.js│ ├── ./build/vue-loader.conf.js│ ├── ./build/webpack.base.conf.js│ ├── ./build/webpack.dev.conf.js│ ├── ./build/webpack.devprod.config.js│ ├── ./build/webpack.prod.conf.js│ └── ./build/webpack.prodserver.config.js├── ./config│ ├── ./config/dev.env.js│ ├── ./config/index.js│ └── ./config/prod.env.js├── ./index.html├── ./package-lock.json├── ./package.json├── ./project.config.json├── ./src│ ├── ./src/App.vue│ ├── ./src/app.json│ ├── ./src/main.js│ ├── ./src/components│ │ ├── ./src/components/addRecord.vue│ ├── ./src/config│ │ └── ./src/config/apiconfig│ │ └── ./src/config/apiconfig/config.js│ ├── ./src/fetchData│ │ ├── ./src/fetchData/fetchDiscover.js│ ├── ./src/http│ │ ├── ./src/http/api.js│ │ └── ./src/http/config.js│ ├── ./src/main.js│ ├── ./src/pages│ │ └── ./src/pages/searchlist│ │ ├── ./src/pages/searchlist/component│ │ │ ├── ./src/pages/searchlist/component/courts.vue│ │ │ ├── ./src/pages/searchlist/component/goodsType.vue│ │ │ ├── ./src/pages/searchlist/component/priceRange.vue│ │ │ └── ./src/pages/searchlist/component/sortView.vue│ │ ├── ./src/pages/searchlist/index.vue│ │ ├── ./src/pages/searchlist/main.js│ │ └── ./src/pages/searchlist/main.json│ ├── ./src/store│ │ ├── ./src/store/actions.js│ │ ├── ./src/store/getters.js│ │ ├── ./src/store/mutaions.js│ │ ├── ./src/store/mutation-type.js│ │ └── ./src/store/store.js│ └── ./src/utils│ ├── ./src/utils/data│ │ ├── ./src/utils/data/city.js│ │ ├── ./src/utils/data/discoverData.js│ │ ├── ./src/utils/data/handleUtils.js│ │ ├── ./src/utils/data/mincity.js│ │ └── ./src/utils/data/region.json│ ├── ./src/utils/style│ │ ├── ./src/utils/style/common.css│ │ └── ./src/utils/style/mixin.css│ └── ./src/utils/tipUtil│ └── ./src/utils/tipUtil/tips.js└── ./static ├── ./static/images │ ├── ./static/images/default_pic.png ├── ./static/iview │ ├── ./static/iview/action-sheet │ │ ├── ./static/iview/action-sheet/index.js │ │ ├── ./static/iview/action-sheet/index.json │ │ ├── ./static/iview/action-sheet/index.wxml │ │ └── ./static/iview/action-sheet/index.wxss └── ./static/weui └── ./static/weui/weui.css 上线流程图中我们先分析下结构，build和config目录是存放webpack配置文件的，有需要特殊配置的小伙伴自行修改配置即可。 剩下的的就是src和static目录，初期构建出来的项目并没有static目录，但是能知道它的作用存放静态文件的,具体后面讲。 index.html是作为解析mpvue入口html文件 project.config.json这个文件是用来设置小程序开发工具设置和appid的配置文件 再到src目录，components存放vue组件，config和http是封装请求方法的，utils是存放公共方法类文件的，pages是存放页面级文件的，每个page里有三个文件，分别是index.vue、main.js、main.json。 src里有三个文件，main.js、App.vue,这两个分别对应vue框架中的入口js文件和入口模板，还有个app.json这是小程序配置路由等信息的文件 解析上诉内容目录1、static目录的作用static是存放静态文件的，mpvue框架由于目前架构还不是很成熟，所以在页面中引入图片资源时将图片放到src目录下，打包到dist，引入图片是加载不出来的。所以目前就先将static目录以webpack的copy方法将static目录copy到dist目录，方便小程序的导入。同时我们想着如何引入三方的小程序UI库，这时候想到mpvue是将vue代码装成小程序代码，我们将小程序的UI组件引入到dist目录即可，供mpvue使用。要做到这点寿险将需要的UI组件存放到static对应的文件夹下。然后页面中如何使用呢，就需要到page目录下的main.json文件中配置了，看下面代码： 123456&#123; "navigationBarTitleText": "页面标题", "usingComponents": &#123; "i-icon": "../../static/iview/icon/index" &#125;&#125; 这样引入后在页面中直接使用组件即可：1&lt;i-icon class="iconUnfold" type="unfold" /&gt; 2、store如何使用store的使用和vue的使用是几乎一样的，不一样的在于它的引入及store存储的set和get需要改成小程序的方法。 1、在main.js入口文件时将store实例化对象引入到vue类的原型上1Vue.prototype.$store = store 这一点和vue是不一样的 2、vuex的set和get需要自己写，用到vuex-persistedstate库来实现set和get12345678910111213141516171819202122import createPersistedState from 'vuex-persistedstate'const store = new Vuex.Store(&#123; state, getters, mutations, actions, modules: &#123; &#125;, plugins: [createPersistedState(&#123; // 配置白名单 paths: [ 'ztInfo', 'isLogin' ], storage: &#123; getItem: key =&gt; wx.getStorageSync(key), setItem: (key, value) =&gt; wx.setStorageSync(key, value), removeItem: key =&gt; &#123;&#125; &#125; &#125;)]&#125;) 做完这些，vuex就可以在项目中使用起来了 3、路由的使用 说到路由，有人讲到咋没看到vue-router啊，只能很抱歉的说一句目前还未很好的接入vue的路由，现阶段只能使用小程序的路由配置。 小程序的路由就需要用到src/app.json 1234567891011121314151617181920212223242526272829&#123; "pages": [ "pages/discover/main", // 页面路径 ], "window": &#123; // 全局窗口配置 "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#F73C31", "navigationBarTitleText": "展堂拍卖", "navigationBarTextStyle": "#ffffff" &#125;, "tabBar": &#123; // 底部导航切换 "color":"#000000", "selectedColor": "#f0220d", "list": [ &#123; "pagePath": "pages/discover/main", "text": "现场勘察", "iconPath": "static/images/nav_bottom2/nav_1.png", "selectedIconPath": "static/images/nav_bottom2/nav_1_on.png" &#125;, &#123; "pagePath": "pages/reservations/main", "text": "预约看样", "iconPath": "static/images/nav_bottom2/nav_2.png", "selectedIconPath": "static/images/nav_bottom2/nav_2_on.png" &#125; ] &#125;&#125; 4、project.config.json部分讲解123456789101112131415161718192021222324252627282930313233&#123; "description": "项目配置文件。", "setting": &#123; "urlCheck": true, "es6": false, // 是否将es6转成es5 "postcss": true, "minified": true, "newFeature": true &#125;, "miniprogramRoot": "dist/", // 小程序根目录 "compileType": "miniprogram", "appid": "wx86d90741d5d57774", // 小程序appid "projectname": "zhantang-fapai-wx-staff", // 项目名称 "libVersion": "2.3.2", // 使用基础调试库的版本 "condition": &#123; "search": &#123; "current": -1, "list": [] &#125;, "conversation": &#123; "current": -1, "list": [] &#125;, "game": &#123; "currentL": -1, "list": [] &#125;, "miniprogram": &#123; "current": -1, "list": [] &#125; &#125;&#125; 上诉注解的信息都可以在小程序工具中的详情中配置 讲述了这些基本上一个框架使用就可以开始了，剩下的接口封装，store实现就不详细讲了，接口封装我用的是flyio，store实现上面也讲了重要的点。 mpvue开发中遇到的坑点mpvue中vue的大部分功能都可以使用，但是有一些会存在问题。 vue中可以使用filter过滤，mpvue不行 vue中可以使用dom中methods方法调用获取返回值， 在mpvue中不行，可以考虑用computed计算实现 vue中常用的slot在mpvue也成了鸡肋 原生组件上不要使用v-if，例如map将会导致地图位置不刷新，水印，canvas组件将会不更新数据等 重点说下slot我遇到的坑，在vue中使用slot使用是对slot进行具名匹配，slot中的dom作用域是父组件的作用域，slot中组件同时可以继续嵌套。 那再mpvue中是什么个样子呢。。。我只想说12345678910111213141516```javascript&lt;select-city @onCityChange=&quot;onCityChange&quot; :selectAddress=&quot;selectAddress&quot;&gt; &lt;template slot=&quot;default&quot;&gt; &lt;section class=&quot;pickSection&quot;&gt; &lt;div class=&quot;picker&quot;&gt;&#123;&#123;selectAddress || &apos;地区&apos;&#125;&#125;&lt;/div&gt; &lt;i-icon class=&quot;iconUnfold&quot; type=&quot;unfold&quot; /&gt; &lt;/section&gt; &lt;/template&gt;&lt;/select-city&gt;```上面这块代码是mpvue中截取的，&lt;select-city/&gt;是个地址选择器组件，原先我要实现的功能是传个onCityChange方法进去并返回给我地址信息。然后将地址信息存到selectAddress变量里，再刷新到`&lt;div class=&quot;picker&quot;&gt;&#123;&#123;selectAddress || &apos;地区&apos;&#125;&#125;&lt;/div&gt;`这里，然而这么做了，然并卵 最后查阅资料后我才知道，mpvue中的slot只能传静态数据，且需要对slot具名，slot嵌套无效，更尴尬的是，slot中的作用域竟然是在子组件里。我有点蒙，然后就在父组件上传递了个selectAddress,然后才能获取地址信息。对于slot大家极力要求此功能完善下，目前为止还未实现 如果在小程序原生组件上例如map和canvas中使用v-if，mpvue在改变数据时会发现视图并未刷新。我采取的解决措施是将视图dom保留在文档流中，将组件定位到视图看不到的地方，符合条件再将之定位到需要的地方即可。 这里只阐述我遇到的坑~~~后续遇到将继续更新]]></content>
      <categories>
        <category>mpvue</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React高阶组件(HOC)入门]]></title>
    <url>%2F2018%2F11%2F16%2FReact%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;之前的文章React Mixins入门指南介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。Dan Abramov在文章Mixins Considered Harmful介绍了Mixin带来的一些问题,总结下来主要是以下几点: 破坏组件封装性: Mixin可能会引入不可见的属性。例如在渲染组件中使用Mixin方法，给组件带来了不可见的属性(props)和状态(state)。并且Mixin可能会相互依赖，相互耦合，不利于代码维护。 不同的Mixin中的方法可能会相互冲突 为了处理上述的问题，React官方推荐使用高阶组件(High Order Component) 高阶组件(HOC) &nbsp;&nbsp;&nbsp;&nbsp;刚开始学习高阶组件时，这个概念就透漏着高级的气味，看上去就像是一种先进的编程技术的一个深奥术语，毕竟名字里就有”高阶”这种字眼，实质上并不是如此。高阶组件的概念应该是来源于JavaScript的高阶函数: 高阶函数就是接受函数作为输入或者输出的函数 这么看来柯里化也是高阶函数了。React官方定义高阶组件的概念是: A higher-order component is a function that takes a component and returns a new component. &nbsp;&nbsp;&nbsp;&nbsp;(参照翻译了React官方文档的Advanced Guides部分，官方的高阶组件中文文档戳这里) &nbsp;&nbsp;&nbsp;&nbsp;这么看来，高阶组件仅仅只是是一个接受组件组作输入并返回组件的函数。看上去并没有什么，那么高阶组件能为我们带来什么呢？首先看一下高阶组件是如何实现的，通常情况下，实现高阶组件的方式有以下两种: 属性代理(Props Proxy) 反向继承(Inheritance Inversion) 属性代理&nbsp;&nbsp;&nbsp;&nbsp;又是一个听起来很高大上的名词，实质上是通过包裹原来的组件来操作props，举个简单的例子: 123456789101112131415161718import React, &#123; Component &#125; from 'React';//高阶组件定义const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125;&#125;//普通的组件class WrappedComponent extends Component&#123; render()&#123; //.... &#125;&#125;//高阶组件使用export default HOC(WrappedComponent) &nbsp;&nbsp;&nbsp;&nbsp;上面的例子非常简单，但足以说明问题。我们可以看见函数HOC返回了新的组件(WrapperComponent)，这个组件原封不动的返回作为参数的组件(也就是被包裹的组件:WrappedComponent)，并将传给它的参数(props)全部传递给被包裹的组件(WrappedComponent)。这么看起来好像并没有什么作用，其实属性代理的作用还是非常强大的。 操作props &nbsp;&nbsp;&nbsp;&nbsp;我们看到之前要传递给被包裹组件WrappedComponent的属性首先传递给了高阶组件返回的组件(WrapperComponent)，这样我们就获得了props的控制权(这也就是为什么这种方法叫做属性代理)。我们可以按照需要对传入的props进行增加、删除、修改(当然修改带来的风险需要你自己来控制)，举个例子: 123456789101112const HOC = (WrappedComponent) =&gt; class WrapperComponent extends Component &#123; render() &#123; const newProps = &#123; name: 'HOC' &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。 获得refs的引用&nbsp;&nbsp;&nbsp;&nbsp;我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(ref)，例如: 1234567891011121314import React, &#123; Component &#125; from 'React'; const HOC = (WrappedComponent) =&gt; class wrapperComponent extends Component &#123; storeRef(ref) &#123; this.ref = ref; &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref = &#123;::this.storeRef&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。 抽象state&nbsp;&nbsp;&nbsp;&nbsp;属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变(关于不受控组件和受控组件戳这里) 123456789101112131415161718192021222324252627282930313233class WrappedComponent extends Component &#123; render() &#123; return &lt;input name="name" &#123;...this.props.name&#125; /&gt;; &#125;&#125;const HOC = (WrappedComponent) =&gt; class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; name: '', &#125;; this.onNameChange = this.onNameChange.bind(this); &#125; onNameChange(event) &#123; this.setState(&#123; name: event.target.value, &#125;) &#125; render() &#123; const newProps = &#123; name: &#123; value: this.state.name, onChange: this.onNameChange, &#125;, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件. 用其他元素包裹组件&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过类似: 12345render()&#123; &lt;div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;&#125; &nbsp;&nbsp;&nbsp;&nbsp;这种方式将被包裹组件包裹起来，来实现布局或者是样式的目的。 &nbsp;&nbsp;&nbsp;&nbsp;在属性代理这种方式实现的高阶组件，以上述为例，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序是先WrapperComponent再WrappedComponent(执行ComponentWillUnmount的时间)。 反向继承&nbsp;&nbsp;&nbsp;&nbsp;反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指) 123456const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:super.render())，这也就是为什么叫做反向继承。 渲染劫持&nbsp;&nbsp;&nbsp;&nbsp;渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件: 12345678910const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; if (this.props.isRender) &#123; return super.render(); &#125; else &#123; return null; &#125; &#125; &#125; &nbsp;&nbsp;&nbsp;&nbsp;甚至我们可以修改修改render的结果: 123456789101112131415161718192021222324//例子来源于《深入React技术栈》const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); let newProps = &#123;&#125;; if (elementsTree &amp;&amp; elementsTree.type === 'input') &#123; newProps = &#123;value: 'may the force be with you'&#125;; &#125; const props = Object.assign(&#123;&#125;, elementsTree.props, newProps); const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children); return newElementsTree; &#125;&#125;class WrappedComponent extends Component&#123; render()&#123; return( &lt;input value=&#123;'Hello World'&#125; /&gt; ) &#125;&#125;export default HOC(WrappedComponent)//实际显示的效果是input的值为"may the force be with you" &nbsp;&nbsp;&nbsp;&nbsp;上面的例子中我们将WrappedComponent中的input元素value值修改为:may the force be with you。我们可以看到前后elementTree的区别:elementsTree: &nbsp;&nbsp;&nbsp;&nbsp;newElementsTree: &nbsp;&nbsp;&nbsp;&nbsp;在反向继承中，我们可以做非常多的操作，修改state、props甚至是翻转Element Tree。反向继承有一个重要的点: 反向继承不能保证完整的子组件树被解析，开始我对这个概念也不理解，后来在看了React Components, Elements, and Instances这篇文章之后对这个概念有了自己的一点体会。React Components, Elements, and Instances这篇文章主要明确了一下几个点: &nbsp;&nbsp;&nbsp;&nbsp; + 元素(element)是一个是用DOM节点或者组件来描述屏幕显示的纯对象，元素可以在属性(props.children)中包含其他的元素，一旦创建就不会改变。我们通过JSX和React.createClass创建的都是元素。&nbsp;&nbsp;&nbsp;&nbsp; + 组件(component)可以接受属性(props)作为输入，然后返回一个元素树(element tree)作为输出。有多种实现方式:Class或者函数(Function)。 &nbsp;&nbsp;&nbsp;&nbsp;所以，反向继承不能保证完整的子组件树被解析的意思的解析的元素树中包含了组件(函数类型或者Class类型)，就不能再操作组件的子组件了，这就是所谓的不能完全解析。举个例子: 123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';const MyFuncComponent = (props)=&gt;&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; );&#125;class MyClassComponent extends Component&#123; render()&#123; return ( &lt;div&gt;Hello World&lt;/div&gt; ) &#125;&#125;class WrappedComponent extends Component&#123; render()&#123; return( &lt;div&gt; &lt;div&gt; &lt;span&gt;Hello World&lt;/span&gt; &lt;/div&gt; &lt;MyFuncComponent /&gt; &lt;MyClassComponent /&gt; &lt;/div&gt; ) &#125;&#125;const HOC = (WrappedComponent) =&gt; class extends WrappedComponent &#123; render() &#123; const elementsTree = super.render(); return elementsTree; &#125; &#125;export default HOC(WrappedComponent); &nbsp;&nbsp;&nbsp;&nbsp;我们可以查看解析的元素树(element tree)，div下的span是可以被完全被解析的，但是MyFuncComponent和MyClassComponent都是组件类型的，其子组件就不能被完全解析了。 操作props和state&nbsp;&nbsp;&nbsp;&nbsp;在上面的图中我们可以看到，解析的元素树(element tree)中含有props和state(例子的组件中没有state),以及ref和key等值。因此，如果需要的话，我们不仅可以读取props和state,甚至可以修改增加、修改和删除。 &nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，我们可能需要为高阶属性传入一些参数，那我们就可以通过柯里化的形式传入参数，例如: 123456789101112import React, &#123; Component &#125; from 'React';const HOCFactoryFactory = (...params) =&gt; &#123; // 可以做一些改变 params 的事 return (WrappedComponent) =&gt; &#123; return class HOC extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以通过下面方式使用: 1HOCFactoryFactory(params)(WrappedComponent) &nbsp;&nbsp;&nbsp;&nbsp;这种方式是不是非常类似于React-Redux库中的connect函数，因为connect也是类似的一种高阶函数。反向继承不同于属性代理的调用顺序，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序也是先WrappedComponent再WrapperComponent(执行ComponentWillUnmount的时间)。 HOC和Mixin的比较&nbsp;&nbsp;&nbsp;&nbsp;借用《深入React技术栈》一书中的图: &nbsp;&nbsp;&nbsp;&nbsp;高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基础语法]]></title>
    <url>%2F2018%2F11%2F16%2Fmarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. markdown是什么？ Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。 2. markdown语法2.1 标题标题有两种形式：(1) 第一种是用=或者-表示一级或者二级标题 一级标题======二级标题------ 效果如下： 一级标题down二级标题 (2) 第二种就是#来表示1-6级标题，与HTML的h1-h6相似。 123456&gt; #一级标题&gt; ##二级标题&gt; ###三级标题&gt; ####四级标题&gt; #####五级标题&gt; ######六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题2.2 引用在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如： >引用 >>嵌套引用 效果如下： 引用 嵌套引用 2.3 代码块代码块可以在每行加上四个空格来表示代码区域，效果如： function foo(){ return; } 或者在开始与结尾用表示一样可以，效果同上： 123&gt; function foo()&#123;&gt; return;&gt; &#125; 2.4 ``符号``可以用来表示相对较小区域的代码内容，或者起到标记作用，如 `标记` 效果如下： 标记 2.5 强调与斜体在强调内容两侧分别加上*或者_，如： *斜体，_斜体_**粗体**，__粗体__ 效果如下： 斜体，斜体粗体，粗体 2.6 有序列表与无序列表使用*、+、或-标记无序列表，如： (+-) 第一项 (+-) 第二项*(+-) 第三项 效果如下： 第一项 第二项 第三项 使用数字123加上.即是有序列表，如： 第一项 第二项 第三项 效果如下： 1.第一项2.第二项3.第三项 2.7 分割线分割线最常使用就是三个或以上*，还可以使用-和_，如： 我是分割线1***我是分割线2———我是分割线3___ 效果如下： 我是分割线1 我是分割线2我是分割线3 2.8 链接链接由[]与()组成，[]中的指描述，()中跟链接地址，如： [百度](https://www.baidu.com/) 效果如下： 百度 2.9 图片引入 ![图片](图片地址) 效果如下 2.9 表格写法 1234First Header | Second Header | Third Header------------ | ------------- | ------------Content Cell | Content Cell | Content CellContent Cell | Content Cell | Content Cell 在 Markdown 中，可以制作表格，例如： First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA加解密签名用法]]></title>
    <url>%2F2017%2F08%2F11%2FRSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下js语言中， RSA加解密和签名加解密的实现。 分享两个库，都是用来加解密的，https://github.com/kjur/jsrsasign https://github.com/travist/jsencrypt由于jsrsasign库加密业务数据总是出现报错，之后就用了jsencrypt来实现了业务数据的加密，再通过jsrsasign来实现签名以及签名校验 首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码 ，实现加解密要以下几个步骤： （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 （3）乙方得到加密后的信息，用私钥解密。 12345678910111213141516171819export const encryptMethod = (bussinessParams: Object) =&gt; &#123; try &#123; //这部分是加密业务数据的方法 const encrypt = new JSEncrypt() encrypt.setPublicKey(publicKey) const encrypted = encrypt.encrypt(encodeURIComponent( JSON.stringify(bussinessParams))) console.log("公钥加密后，原文 : " + encrypted); return encrypted // 私钥解密 var decrypt = new JSEncrypt(); decrypt.setPrivateKey(privKey); console.log("公钥加密密文 : " + encrypted); var uncrypted = decrypt.decrypt(encrypted); console.log("私钥解密后，原文 : " + uncrypted); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 上面诉说的是业务数据的加密 我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名， 签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码 1234567891011121314151617export const sign = () =&gt; &#123; try &#123; const sig = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig.init(privateKey) sig.updateString(encrypted)//此处encrypted是加密的业务数据 const hSigVal = encodeURIComponent(sig.sign()) const sig1 = new KJUR.crypto.Signature(&#123; alg: 'SHA1withRSA' &#125;) sig1.init(publicKey)//此处需要公钥去对签名进行校验 sig1.updateString(encrypted) const verified = sig1.verify(hSigVal) console.log("签名校验后结果 : " + verified); &#125; catch (e) &#123; Alert.alert(`RSA $&#123;e&#125;`) &#125;&#125; 以下是签名的api文档：https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html签名校验的demo：https://kjur.github.io/jsrsasign/sample/sample-rsasign.html命令生成密钥文档：http://www.cnblogs.com/littleatp/p/5878763.html JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。 用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。 这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能 分段加密方法：123456789101112131415161718192021222324// The right encryption codeJSEncrypt.prototype.encryptLong = function(string) &#123; var k = this.getKey(); var maxLength = (((k.n.bitLength()+7)&gt;&gt;3)-11);//此处是算法来算出你的密钥可以支持的最大加密字符串长度 try &#123; var lt = ""; var ct = ""; if (string.length &gt; maxLength) &#123; lt = string.match(/.&#123;1,117&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.encrypt(entry); ct += t1 ; &#125;); return hex2b64(ct); &#125; var t = k.encrypt(string); var y = hex2b64(t); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 分段解密方法：1234567891011121314151617181920// The error decryption codeJSEncrypt.prototype.decryptLong = function(string) &#123; var k = this.getKey(); var maxLength = ((k.n.bitLength()+7)&gt;&gt;3); try &#123; var string = b64tohex(string); var ct = ""; if (string.length &gt; maxLength) &#123; var lt = string.match(/.&#123;1,128&#125;/g); lt.forEach(function(entry) &#123; var t1 = k.decrypt(entry); ct += t1; &#125;); &#125; var y = k.decrypt(b64tohex(string)); return y; &#125; catch (ex) &#123; return false; &#125;&#125;; 此篇文章只是个人在使用这两个库中的使用的感受，jsencrypt可以加解密但是不存在签名方法， jsrsasign可以签名，但是使用过程中加密方法报错。初次写文章，不到之处还请轻喷！！！]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解applyMiddleware和createStore之间的关系]]></title>
    <url>%2F2017%2F08%2F01%2F%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言不得不佩服redux的作者Dan Abramov，看完applyMiddleware的源码,我的感受就是：还有这种操作？与其说是理解applyMiddleware，不如说是理清createStore，applyMiddleware和一些中间件的关系，和为什么中间件都是export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}三层嵌套关系。 export default function applyMiddleware() { for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) { middlewares[_key] = arguments[_key]; } return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: function dispatch(action) { return _dispatch(action); } }; chain = middlewares.map(function (middleware) { return middleware(middlewareAPI); }); _dispatch = compose.apply(undefined, chain)(store.dispatch); return _extends({}, store, { dispatch: _dispatch }); }; }; } 精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）： 首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。 const store = createStore( reducer, undefined, enhancer ) 其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。 if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.'); } return enhancer(createStore)(reducer, preloadedState); } 最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。 return function (createStore) { return function (reducer, preloadedState, enhancer) { var store = createStore(reducer, preloadedState, enhancer); //省略一万行 } } 至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。 菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。著作权归作者所有。商业转载请联系作者获得授权,非商业转载请注明出处。]]></content>
      <categories>
        <category>react</category>
        <category>redux</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
