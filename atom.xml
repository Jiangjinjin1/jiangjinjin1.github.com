<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fighting of erha</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiangjinjin1.github.io/"/>
  <updated>2018-11-16T06:04:46.703Z</updated>
  <id>https://jiangjinjin1.github.io/</id>
  
  <author>
    <name>fighting of erha</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>markdown基础语法</title>
    <link href="https://jiangjinjin1.github.io/2018/11/16/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://jiangjinjin1.github.io/2018/11/16/markdown基础语法/</id>
    <published>2018-11-16T05:59:03.000Z</published>
    <updated>2018-11-16T06:04:46.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-markdown是什么？"><a href="#1-markdown是什么？" class="headerlink" title="1. markdown是什么？"></a>1. markdown是什么？</h1><blockquote><p>Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。<br>Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。</p></blockquote><a id="more"></a><h1 id="2-markdown语法"><a href="#2-markdown语法" class="headerlink" title="2. markdown语法"></a>2. markdown语法</h1><h2 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h2><p>标题有两种形式：<br>(1) 第一种是用=或者-表示一级或者二级标题</p><blockquote><p>一级标题<br><code>======</code><br>二级标题<br><code>------</code></p></blockquote><p>效果如下：</p><blockquote><h1 id="一级标题down"><a href="#一级标题down" class="headerlink" title="一级标题down"></a>一级标题down</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>(2) 第二种就是#来表示1-6级标题，与HTML的h1-h6相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; #一级标题</span><br><span class="line">&gt; ##二级标题</span><br><span class="line">&gt; ###三级标题</span><br><span class="line">&gt; ####四级标题</span><br><span class="line">&gt; #####五级标题</span><br><span class="line">&gt; ######六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h2><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：</p><blockquote><p>>引用<br>  >>嵌套引用</p></blockquote><p>效果如下：</p><blockquote><p>引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h2 id="2-3-代码块"><a href="#2-3-代码块" class="headerlink" title="2.3 代码块"></a>2.3 代码块</h2><p>代码块可以在每行加上四个空格来表示代码区域，效果如：</p><blockquote><p>   function foo(){<br>         return;<br>   }</p></blockquote><p>或者在开始与结尾用表示一样可以，效果同上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt; <span class="keyword">return</span>;</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-符号"><a href="#2-4-符号" class="headerlink" title="2.4 ``符号"></a>2.4 ``符号</h2><p>``可以用来表示相对较小区域的代码内容，或者起到标记作用，如</p><blockquote><p>`标记`</p></blockquote><p>效果如下：</p><blockquote><p><code>标记</code></p></blockquote><h2 id="2-5-强调与斜体"><a href="#2-5-强调与斜体" class="headerlink" title="2.5 强调与斜体"></a>2.5 强调与斜体</h2><p>在强调内容两侧分别加上*或者_，如：</p><blockquote><p>*斜体，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果如下：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h2 id="2-6-有序列表与无序列表"><a href="#2-6-有序列表与无序列表" class="headerlink" title="2.6 有序列表与无序列表"></a>2.6 有序列表与无序列表</h2><p>使用*、+、或-标记无序列表，如：</p><blockquote><p>(+-) 第一项 (+-) 第二项<br>*(+-) 第三项</p></blockquote><p>效果如下：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>使用数字123加上.即是有序列表，如：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><p>效果如下：</p><blockquote><p>1.第一项<br>2.第二项<br>3.第三项</p></blockquote><h2 id="2-7-分割线"><a href="#2-7-分割线" class="headerlink" title="2.7 分割线"></a>2.7 分割线</h2><p>分割线最常使用就是三个或以上*，还可以使用-和_，如：</p><blockquote><p>我是分割线1<br>***<br>我是分割线2<br>———<br>我是分割线3<br>___</p></blockquote><p>效果如下：</p><p>我是分割线1</p><hr><h2 id="我是分割线2"><a href="#我是分割线2" class="headerlink" title="我是分割线2"></a>我是分割线2</h2><p>我是分割线3</p><hr><h2 id="2-8-链接"><a href="#2-8-链接" class="headerlink" title="2.8 链接"></a>2.8 链接</h2><p>链接由[]与()组成，[]中的指描述，()中跟链接地址，如：</p><blockquote><p>[百度](<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a>)</p></blockquote><p>效果如下：</p><blockquote><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a></p></blockquote><h2 id="2-9-图片引入"><a href="#2-9-图片引入" class="headerlink" title="2.9 图片引入"></a>2.9 图片引入</h2><blockquote><p>![图片](图片地址)</p></blockquote><p>效果如下</p><blockquote><p><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6h85RMsib6oGMKz0eibALsD1ricmicj6gUbUWAOs0C6Ynhf7Na6IBLyoWpHxTnHAZoAdznwicTf1Xaa61xdnEjV1QTg/132" alt="图片"></p></blockquote><p>2.9 表格<br>写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First Header | Second Header | Third Header</span><br><span class="line">------------ | ------------- | ------------</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br></pre></td></tr></table></figure><p>在 Markdown 中，可以制作表格，例如：</p><table><thead><tr><th>First Header</th><th>Second Header</th><th>Third Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-markdown是什么？&quot;&gt;&lt;a href=&quot;#1-markdown是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. markdown是什么？&quot;&gt;&lt;/a&gt;1. markdown是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。&lt;br&gt;Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RSA加解密签名用法</title>
    <link href="https://jiangjinjin1.github.io/2017/08/11/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95/"/>
    <id>https://jiangjinjin1.github.io/2017/08/11/RSA加解密签名用法/</id>
    <published>2017-08-11T03:26:23.000Z</published>
    <updated>2018-11-16T05:48:55.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下<code>js</code>语言中， RSA加解密和签名加解密的实现。</p><a id="more"></a><p>分享两个库，都是用来加解密的，<a href="https://github.com/kjur/jsrsasign" target="_blank" rel="noopener">https://github.com/kjur/jsrsasign</a> <a href="https://github.com/travist/jsencrypt" target="_blank" rel="noopener">https://github.com/travist/jsencrypt</a><br>由于<code>jsrsasign</code>库加密业务数据总是出现报错，之后就用了<code>jsencrypt</code>来实现了业务数据的加密，再通过<code>jsrsasign</code>来实现签名以及签名校验</p><p><code>首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码，实现加解密要以下几个步骤：　　（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。　　（2）甲方获取乙方的公钥，然后用它对信息加密。　　（3）乙方得到加密后的信息，用私钥解密。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> encryptMethod = <span class="function">(<span class="params">bussinessParams: <span class="built_in">Object</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这部分是加密业务数据的方法</span></span><br><span class="line">    <span class="keyword">const</span> encrypt = <span class="keyword">new</span> JSEncrypt()</span><br><span class="line">    encrypt.setPublicKey(publicKey)</span><br><span class="line">    <span class="keyword">const</span> encrypted = encrypt.encrypt(<span class="built_in">encodeURIComponent</span>(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(bussinessParams)))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密后，原文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line">    <span class="comment">// 私钥解密</span></span><br><span class="line">    <span class="keyword">var</span> decrypt = <span class="keyword">new</span> JSEncrypt();</span><br><span class="line">    decrypt.setPrivateKey(privKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密密文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">var</span> uncrypted = decrypt.decrypt(encrypted);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"私钥解密后，原文 : "</span> + uncrypted);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面诉说的是业务数据的加密</p><p><code>我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名，签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sign = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sig = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig.init(privateKey)</span><br><span class="line">    sig.updateString(encrypted)<span class="comment">//此处encrypted是加密的业务数据</span></span><br><span class="line">    <span class="keyword">const</span> hSigVal = <span class="built_in">encodeURIComponent</span>(sig.sign())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sig1 = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig1.init(publicKey)<span class="comment">//此处需要公钥去对签名进行校验</span></span><br><span class="line">    sig1.updateString(encrypted)</span><br><span class="line">    <span class="keyword">const</span> verified = sig1.verify(hSigVal)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"签名校验后结果 : "</span> + verified);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是签名的api文档：<a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html</a><br>签名校验的demo：<a href="https://kjur.github.io/jsrsasign/sample/sample-rsasign.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/sample/sample-rsasign.html</a><br>命令生成密钥文档：<a href="http://www.cnblogs.com/littleatp/p/5878763.html" target="_blank" rel="noopener">http://www.cnblogs.com/littleatp/p/5878763.html</a></p><p><code>JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能</code></p><p>分段加密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The right encryption code</span></span><br><span class="line">JSEncrypt.prototype.encryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = (((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>)<span class="number">-11</span>);<span class="comment">//此处是算法来算出你的密钥可以支持的最大加密字符串长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lt = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      lt = string.match(<span class="regexp">/.&#123;1,117&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.encrypt(entry);</span><br><span class="line">        ct += t1 ;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> hex2b64(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t = k.encrypt(string);</span><br><span class="line">    <span class="keyword">var</span> y = hex2b64(t);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>分段解密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error decryption code</span></span><br><span class="line">JSEncrypt.prototype.decryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = ((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> string = b64tohex(string);</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      <span class="keyword">var</span> lt = string.match(<span class="regexp">/.&#123;1,128&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.decrypt(entry);</span><br><span class="line">        ct += t1;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y = k.decrypt(b64tohex(string));</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此篇文章只是个人在使用这两个库中的使用的感受，<code>jsencrypt</code>可以加解密但是不存在签名方法， <code>jsrsasign</code>可以签名，但是使用过程中加密方法报错。<br>初次写文章，不到之处还请轻喷！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下&lt;code&gt;js&lt;/code&gt;语言中， RSA加解密和签名加解密的实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解applyMiddleware和createStore之间的关系</title>
    <link href="https://jiangjinjin1.github.io/2017/08/01/%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://jiangjinjin1.github.io/2017/08/01/理解redux中的applyMiddleware与中间件/</id>
    <published>2017-08-01T03:26:23.000Z</published>
    <updated>2018-11-16T05:49:06.923Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不得不佩服redux的作者<code>Dan Abramov</code>，看完<code>applyMiddleware</code>的源码,我的感受就是：还有这种操作？<br>与其说是理解applyMiddleware，不如说是理清<code>createStore</code>，<code>applyMiddleware</code>和一些中间件的关系，和为什么中间件都是<code>export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}</code>三层嵌套关系。  </p><a id="more"></a><pre><code class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>{  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) {    middlewares[_key] = <span class="built_in">arguments</span>[_key];  }  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);      <span class="keyword">var</span> _dispatch = store.dispatch;      <span class="keyword">var</span> chain = [];      <span class="keyword">var</span> middlewareAPI = {        <span class="attr">getState</span>: store.getState,        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>{          <span class="keyword">return</span> _dispatch(action);        }      };      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>{        <span class="keyword">return</span> middleware(middlewareAPI);      });      _dispatch = compose.apply(<span class="literal">undefined</span>, chain)(store.dispatch);      <span class="keyword">return</span> _extends({}, store, {        <span class="attr">dispatch</span>: _dispatch      });    };  };}</code></pre><p>精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：<br><img src="/images/createStore1.png"><br>enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数<br><img src="/images/applyMiddleware1.png"><br>两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）：  </p><p><code>首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。</code>  </p><pre><code class="javascript"><span class="keyword">const</span> store = createStore(    reducer,    <span class="literal">undefined</span>,    enhancer  )</code></pre><p><code>其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。</code>  </p><pre><code class="javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) {    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) {      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);    }    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);  }</code></pre><p><code>最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。</code></p><pre><code class="javascript"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);    <span class="comment">//省略一万行</span>  }}</code></pre><p>至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。<br><img src="/images/applyMiddleware2.png"></p><h4 id="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"><a href="#菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。" class="headerlink" title="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"></a>菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</h4><p>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不得不佩服redux的作者&lt;code&gt;Dan Abramov&lt;/code&gt;，看完&lt;code&gt;applyMiddleware&lt;/code&gt;的源码,我的感受就是：还有这种操作？&lt;br&gt;与其说是理解applyMiddleware，不如说是理清&lt;code&gt;createStore&lt;/code&gt;，&lt;code&gt;applyMiddleware&lt;/code&gt;和一些中间件的关系，和为什么中间件都是&lt;code&gt;export const createThunkMiddleware = ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt; {...}&lt;/code&gt;三层嵌套关系。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
