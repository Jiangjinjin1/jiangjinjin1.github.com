<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fighting of erha</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiangjinjin1.github.io/"/>
  <updated>2018-11-29T05:45:25.364Z</updated>
  <id>https://jiangjinjin1.github.io/</id>
  
  <author>
    <name>fighting of erha</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac中使用生成项目结构图tree</title>
    <link href="https://jiangjinjin1.github.io/2018/11/29/mac%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%9B%BEtree/"/>
    <id>https://jiangjinjin1.github.io/2018/11/29/mac中使用生成项目结构图tree/</id>
    <published>2018-11-29T02:06:31.000Z</published>
    <updated>2018-11-29T05:45:25.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h1><blockquote><p>Mac 的话是没有自带tree命令的，但是我们可以通过homebrew（如果你不知道它的话，这是官网）安装：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">brew install tree</span><br></pre></td></tr></table></figure><blockquote><p>然后等待安装完成后</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree --version# 查看是否安装成功</span><br><span class="line">tree --help# 查看帮助</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="中文Api"><a href="#中文Api" class="headerlink" title="中文Api"></a>中文Api</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-a 显示所有文件和目录。</span><br><span class="line">-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span><br><span class="line">-C 在文件和目录清单加上色彩，便于区分各种类型。</span><br><span class="line">-d 显示目录名称而非内容。</span><br><span class="line">-D 列出文件或目录的更改时间。</span><br><span class="line">-f 在每个文件或目录之前，显示完整的相对路径名称。</span><br><span class="line">-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上<span class="string">"*"</span>,<span class="string">"/"</span>,<span class="string">"="</span>,<span class="string">"@"</span>,<span class="string">"|"</span>号。</span><br><span class="line">-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span><br><span class="line">-i 不以阶梯状列出文件或目录名称。</span><br><span class="line">-I 不显示符合范本样式的文件或目录名称。</span><br><span class="line">-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span><br><span class="line">-n 不在文件和目录清单加上色彩。</span><br><span class="line">-N 直接列出文件和目录名称，包括控制字符。</span><br><span class="line">-p 列出权限标示。</span><br><span class="line">-P 只显示符合范本样式的文件或目录名称。</span><br><span class="line">-q 用<span class="string">"?"</span>号取代控制字符，列出文件和目录名称。</span><br><span class="line">-s 列出文件或目录大小。</span><br><span class="line">-t 用文件和目录的更改时间排序。</span><br><span class="line">-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span><br><span class="line">-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span><br></pre></td></tr></table></figure><h1 id="Used"><a href="#Used" class="headerlink" title="Used"></a>Used</h1><blockquote><p>下面是我生成上面的结构所用的命令，大家可以参考下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree -I <span class="string">'node_modules|dist|*.mp3|*.jpg'</span> -f</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Mac 的话是没有自带tree命令的，但是我们可以通过homebrew（如果你不知道它的话，这是官网）安装：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;brew install tree&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;然后等待安装完成后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tree --version	# 查看是否安装成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tree --help		# 查看帮助&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具类" scheme="https://jiangjinjin1.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="https://jiangjinjin1.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>mpvue入手及遇到的坑点</title>
    <link href="https://jiangjinjin1.github.io/2018/11/29/mpvue%E5%85%A5%E6%89%8B%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E7%82%B9/"/>
    <id>https://jiangjinjin1.github.io/2018/11/29/mpvue入手及遇到的坑点/</id>
    <published>2018-11-29T01:59:37.000Z</published>
    <updated>2018-11-29T05:45:37.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于未接触过<code>小程序</code>的我来说，想起手做个小程序还是要费点时间去学习，但是<code>mpvue</code>的出现让我提起了做小程序的兴趣。从而我的第一个小程序就这么从<code>mpvue</code>中摸爬滚打中开始了</p><a id="more"></a><h2 id="mpvue"><a href="#mpvue" class="headerlink" title="mpvue"></a>mpvue</h2><blockquote><p>mpvue是什么，是一个利用vue的runtime和compiler将vue类型文件的代码通过webpack打包转译成小程序的代码。</p></blockquote><p>让我们先从如何获取一个<code>mpvue</code>脚手架开始起步吧</p><p>首先准备好node，然后在命令行中执行以下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 1. 先检查下 Node.js 是否安装成功</span><br><span class="line">$ node -v</span><br><span class="line">v8<span class="number">.9</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">$ npm -v</span><br><span class="line"><span class="number">5.6</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"># 2. 由于众所周知的原因，可以考虑切换源为 taobao 源</span><br><span class="line">$ npm set registry https:<span class="comment">//registry.npm.taobao.org/</span></span><br><span class="line"></span><br><span class="line"># 3. 全局安装 vue-cli</span><br><span class="line"># 一般是要 sudo 权限的</span><br><span class="line">$ npm install --global vue-cli@<span class="number">2.9</span></span><br><span class="line"></span><br><span class="line"># 4. 创建一个基于 mpvue-quickstart 模板的新项目</span><br><span class="line"># 新手一路回车选择默认就可以了</span><br><span class="line">$ vue init mpvue/mpvue-quickstart my-project</span><br><span class="line"></span><br><span class="line"># 5. 安装依赖，走你</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><ul><li><p>依次执行上面的命令，到最后安装好所以依赖，执行<code>npm run dev</code>这时候本地服务就启动了，项目目录中会多出个dist目录了。</p></li><li><p>上面是摘自:       mpvue文档[<a href="http://mpvue.com/mpvue/quickstart/#3-mpvue" target="_blank" rel="noopener">http://mpvue.com/mpvue/quickstart/#3-mpvue</a>]</p></li><li>剩下的不多说小伙伴们直接去官方文档看就好了，只介绍个起步，下面我们将开始讲述我mpvue的开发过程</li></ul><h2 id="mpvue开发的框架图"><a href="#mpvue开发的框架图" class="headerlink" title="mpvue开发的框架图"></a>mpvue开发的框架图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">├── ./README.md</span><br><span class="line">├── ./build</span><br><span class="line">│   ├── ./build/build.js</span><br><span class="line">│   ├── ./build/check-versions.js</span><br><span class="line">│   ├── ./build/dev-client.js</span><br><span class="line">│   ├── ./build/dev-server.js</span><br><span class="line">│   ├── ./build/devbuild.js</span><br><span class="line">│   ├── ./build/prod-server.js</span><br><span class="line">│   ├── ./build/utils.js</span><br><span class="line">│   ├── ./build/vue-loader.conf.js</span><br><span class="line">│   ├── ./build/webpack.base.conf.js</span><br><span class="line">│   ├── ./build/webpack.dev.conf.js</span><br><span class="line">│   ├── ./build/webpack.devprod.config.js</span><br><span class="line">│   ├── ./build/webpack.prod.conf.js</span><br><span class="line">│   └── ./build/webpack.prodserver.config.js</span><br><span class="line">├── ./config</span><br><span class="line">│   ├── ./config/dev.env.js</span><br><span class="line">│   ├── ./config/index.js</span><br><span class="line">│   └── ./config/prod.env.js</span><br><span class="line">├── ./index.html</span><br><span class="line">├── ./package-lock.json</span><br><span class="line">├── ./package.json</span><br><span class="line">├── ./project.config.json</span><br><span class="line">├── ./src</span><br><span class="line">│   ├── ./src/App.vue</span><br><span class="line">│   ├── ./src/app.json</span><br><span class="line">│   ├── ./src/main.js</span><br><span class="line">│   ├── ./src/components</span><br><span class="line">│   │   ├── ./src/components/addRecord.vue</span><br><span class="line">│   ├── ./src/config</span><br><span class="line">│   │   └── ./src/config/apiconfig</span><br><span class="line">│   │       └── ./src/config/apiconfig/config.js</span><br><span class="line">│   ├── ./src/fetchData</span><br><span class="line">│   │   ├── ./src/fetchData/fetchDiscover.js</span><br><span class="line">│   ├── ./src/http</span><br><span class="line">│   │   ├── ./src/http/api.js</span><br><span class="line">│   │   └── ./src/http/config.js</span><br><span class="line">│   ├── ./src/main.js</span><br><span class="line">│   ├── ./src/pages</span><br><span class="line">│   │   └── ./src/pages/searchlist</span><br><span class="line">│   │       ├── ./src/pages/searchlist/component</span><br><span class="line">│   │       │   ├── ./src/pages/searchlist/component/courts.vue</span><br><span class="line">│   │       │   ├── ./src/pages/searchlist/component/goodsType.vue</span><br><span class="line">│   │       │   ├── ./src/pages/searchlist/component/priceRange.vue</span><br><span class="line">│   │       │   └── ./src/pages/searchlist/component/sortView.vue</span><br><span class="line">│   │       ├── ./src/pages/searchlist/index.vue</span><br><span class="line">│   │       ├── ./src/pages/searchlist/main.js</span><br><span class="line">│   │       └── ./src/pages/searchlist/main.json</span><br><span class="line">│   ├── ./src/store</span><br><span class="line">│   │   ├── ./src/store/actions.js</span><br><span class="line">│   │   ├── ./src/store/getters.js</span><br><span class="line">│   │   ├── ./src/store/mutaions.js</span><br><span class="line">│   │   ├── ./src/store/mutation-type.js</span><br><span class="line">│   │   └── ./src/store/store.js</span><br><span class="line">│   └── ./src/utils</span><br><span class="line">│       ├── ./src/utils/data</span><br><span class="line">│       │   ├── ./src/utils/data/city.js</span><br><span class="line">│       │   ├── ./src/utils/data/discoverData.js</span><br><span class="line">│       │   ├── ./src/utils/data/handleUtils.js</span><br><span class="line">│       │   ├── ./src/utils/data/mincity.js</span><br><span class="line">│       │   └── ./src/utils/data/region.json</span><br><span class="line">│       ├── ./src/utils/style</span><br><span class="line">│       │   ├── ./src/utils/style/common.css</span><br><span class="line">│       │   └── ./src/utils/style/mixin.css</span><br><span class="line">│       └── ./src/utils/tipUtil</span><br><span class="line">│           └── ./src/utils/tipUtil/tips.js</span><br><span class="line">└── ./<span class="keyword">static</span></span><br><span class="line">    ├── ./<span class="keyword">static</span>/images</span><br><span class="line">    │   ├── ./<span class="keyword">static</span>/images/default_pic.png</span><br><span class="line">    ├── ./<span class="keyword">static</span>/iview</span><br><span class="line">    │   ├── ./<span class="keyword">static</span>/iview/action-sheet</span><br><span class="line">    │   │   ├── ./<span class="keyword">static</span>/iview/action-sheet/index.js</span><br><span class="line">    │   │   ├── ./<span class="keyword">static</span>/iview/action-sheet/index.json</span><br><span class="line">    │   │   ├── ./<span class="keyword">static</span>/iview/action-sheet/index.wxml</span><br><span class="line">    │   │   └── ./<span class="keyword">static</span>/iview/action-sheet/index.wxss</span><br><span class="line">    └── ./<span class="keyword">static</span>/weui</span><br><span class="line">        └── ./<span class="keyword">static</span>/weui/weui.css</span><br></pre></td></tr></table></figure><ul><li><p>上线流程图中我们先分析下结构，build和config目录是存放webpack配置文件的，有需要特殊配置的小伙伴自行修改配置即可。</p></li><li><p>剩下的的就是src和static目录，初期构建出来的项目并没有static目录，但是能知道它的作用存放静态文件的,具体后面讲。</p></li><li><p>index.html是作为解析mpvue入口html文件</p></li><li><p>project.config.json这个文件是用来设置小程序开发工具设置和appid的配置文件</p></li><li><p>再到src目录，components存放vue组件，config和http是封装请求方法的，utils是存放公共方法类文件的，pages是存放页面级文件的，每个page里有三个文件，分别是index.vue、main.js、main.json。</p></li><li><p>src里有三个文件，main.js、App.vue,这两个分别对应vue框架中的入口js文件和入口模板，还有个app.json这是小程序配置路由等信息的文件</p></li></ul><h3 id="解析上诉内容目录"><a href="#解析上诉内容目录" class="headerlink" title="解析上诉内容目录"></a>解析上诉内容目录</h3><h4 id="1、static目录的作用"><a href="#1、static目录的作用" class="headerlink" title="1、static目录的作用"></a>1、static目录的作用</h4><p>static是存放静态文件的，mpvue框架由于目前架构还不是很成熟，所以在页面中引入图片资源时将图片放到src目录下，打包到dist，引入图片是加载不出来的。所以目前就先将static目录以webpack的copy方法将static目录copy到dist目录，方便小程序的导入。<br>同时我们想着如何引入三方的小程序UI库，这时候想到mpvue是将vue代码装成小程序代码，我们将小程序的UI组件引入到dist目录即可，供mpvue使用。要做到这点寿险将需要的UI组件存放到static对应的文件夹下。<br>然后页面中如何使用呢，就需要到page目录下的main.json文件中配置了，看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"navigationBarTitleText"</span>: <span class="string">"页面标题"</span>,</span><br><span class="line">  <span class="string">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="string">"i-icon"</span>: <span class="string">"../../static/iview/icon/index"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样引入后在页面中直接使用组件即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-icon <span class="class"><span class="keyword">class</span></span>=<span class="string">"iconUnfold"</span> type=<span class="string">"unfold"</span> /&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2、store如何使用"><a href="#2、store如何使用" class="headerlink" title="2、store如何使用"></a>2、store如何使用</h4><p>store的使用和vue的使用是几乎一样的，不一样的在于它的引入及store存储的set和get需要改成小程序的方法。</p><ul><li>1、在main.js入口文件时将store实例化对象引入到vue类的原型上<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$store = store</span><br></pre></td></tr></table></figure></li></ul><p>这一点和vue是不一样的</p><ul><li>2、vuex的set和get需要自己写，用到<code>vuex-persistedstate</code>库来实现set和get<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">'vuex-persistedstate'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state,</span><br><span class="line">getters,</span><br><span class="line">mutations,</span><br><span class="line">actions,</span><br><span class="line">modules: &#123;</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [createPersistedState(&#123;</span><br><span class="line"><span class="comment">// 配置白名单</span></span><br><span class="line">paths: [</span><br><span class="line"><span class="string">'ztInfo'</span>,</span><br><span class="line"><span class="string">'isLogin'</span></span><br><span class="line">],</span><br><span class="line">storage: &#123;</span><br><span class="line">getItem: <span class="function"><span class="params">key</span> =&gt;</span> wx.getStorageSync(key),</span><br><span class="line">setItem: <span class="function">(<span class="params">key, value</span>) =&gt;</span> wx.setStorageSync(key, value),</span><br><span class="line">removeItem: <span class="function"><span class="params">key</span> =&gt;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>做完这些，vuex就可以在项目中使用起来了</p></blockquote><h4 id="3、路由的使用"><a href="#3、路由的使用" class="headerlink" title="3、路由的使用"></a>3、路由的使用</h4><blockquote><p>说到路由，有人讲到咋没看到vue-router啊，只能很抱歉的说一句目前还未很好的接入vue的路由，现阶段只能使用小程序的路由配置。</p></blockquote><ul><li>小程序的路由就需要用到src/app.json</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"pages"</span>: [</span><br><span class="line">    <span class="string">"pages/discover/main"</span>, <span class="comment">// 页面路径</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"window"</span>: &#123; <span class="comment">// 全局窗口配置</span></span><br><span class="line">    <span class="string">"backgroundTextStyle"</span>: <span class="string">"light"</span>,</span><br><span class="line">    <span class="string">"navigationBarBackgroundColor"</span>: <span class="string">"#F73C31"</span>,</span><br><span class="line">    <span class="string">"navigationBarTitleText"</span>: <span class="string">"展堂拍卖"</span>,</span><br><span class="line">    <span class="string">"navigationBarTextStyle"</span>: <span class="string">"#ffffff"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tabBar"</span>: &#123; <span class="comment">// 底部导航切换</span></span><br><span class="line">      <span class="string">"color"</span>:<span class="string">"#000000"</span>,</span><br><span class="line">      <span class="string">"selectedColor"</span>: <span class="string">"#f0220d"</span>,</span><br><span class="line">      <span class="string">"list"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"pagePath"</span>: <span class="string">"pages/discover/main"</span>,</span><br><span class="line">            <span class="string">"text"</span>: <span class="string">"现场勘察"</span>,</span><br><span class="line">            <span class="string">"iconPath"</span>: <span class="string">"static/images/nav_bottom2/nav_1.png"</span>,</span><br><span class="line">            <span class="string">"selectedIconPath"</span>: <span class="string">"static/images/nav_bottom2/nav_1_on.png"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"pagePath"</span>: <span class="string">"pages/reservations/main"</span>,</span><br><span class="line">            <span class="string">"text"</span>: <span class="string">"预约看样"</span>,</span><br><span class="line">            <span class="string">"iconPath"</span>: <span class="string">"static/images/nav_bottom2/nav_2.png"</span>,</span><br><span class="line">            <span class="string">"selectedIconPath"</span>: <span class="string">"static/images/nav_bottom2/nav_2_on.png"</span></span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、project-config-json部分讲解"><a href="#4、project-config-json部分讲解" class="headerlink" title="4、project.config.json部分讲解"></a>4、project.config.json部分讲解</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"description"</span>: <span class="string">"项目配置文件。"</span>,</span><br><span class="line"><span class="string">"setting"</span>: &#123;</span><br><span class="line"><span class="string">"urlCheck"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"es6"</span>: <span class="literal">false</span>, <span class="comment">// 是否将es6转成es5</span></span><br><span class="line"><span class="string">"postcss"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"minified"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"newFeature"</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"miniprogramRoot"</span>: <span class="string">"dist/"</span>, <span class="comment">// 小程序根目录</span></span><br><span class="line"><span class="string">"compileType"</span>: <span class="string">"miniprogram"</span>,</span><br><span class="line"><span class="string">"appid"</span>: <span class="string">"wx86d90741d5d57774"</span>, <span class="comment">// 小程序appid</span></span><br><span class="line"><span class="string">"projectname"</span>: <span class="string">"zhantang-fapai-wx-staff"</span>, <span class="comment">// 项目名称</span></span><br><span class="line"><span class="string">"libVersion"</span>: <span class="string">"2.3.2"</span>, <span class="comment">// 使用基础调试库的版本</span></span><br><span class="line"><span class="string">"condition"</span>: &#123;</span><br><span class="line"><span class="string">"search"</span>: &#123;</span><br><span class="line"><span class="string">"current"</span>: <span class="number">-1</span>,</span><br><span class="line"><span class="string">"list"</span>: []</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"conversation"</span>: &#123;</span><br><span class="line"><span class="string">"current"</span>: <span class="number">-1</span>,</span><br><span class="line"><span class="string">"list"</span>: []</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"game"</span>: &#123;</span><br><span class="line"><span class="string">"currentL"</span>: <span class="number">-1</span>,</span><br><span class="line"><span class="string">"list"</span>: []</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"miniprogram"</span>: &#123;</span><br><span class="line"><span class="string">"current"</span>: <span class="number">-1</span>,</span><br><span class="line"><span class="string">"list"</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上诉注解的信息都可以在小程序工具中的详情中配置<br><img src="/images/mpvue/mpvue1.jpg"></p></blockquote><p>讲述了这些基本上一个框架使用就可以开始了，剩下的接口封装，store实现就不详细讲了，接口封装我用的是flyio，store实现上面也讲了重要的点。</p><h2 id="mpvue开发中遇到的坑点"><a href="#mpvue开发中遇到的坑点" class="headerlink" title="mpvue开发中遇到的坑点"></a>mpvue开发中遇到的坑点</h2><h3 id="mpvue中vue的大部分功能都可以使用，但是有一些会存在问题。"><a href="#mpvue中vue的大部分功能都可以使用，但是有一些会存在问题。" class="headerlink" title="mpvue中vue的大部分功能都可以使用，但是有一些会存在问题。"></a>mpvue中vue的大部分功能都可以使用，但是有一些会存在问题。</h3><ul><li>vue中可以使用filter过滤，mpvue不行</li><li>vue中可以使用dom中methods方法调用获取返回值， 在mpvue中不行，可以考虑用computed计算实现</li><li>vue中常用的slot在mpvue也成了鸡肋</li><li>原生组件上不要使用v-if，例如map将会导致地图位置不刷新，水印，canvas组件将会不更新数据等</li></ul><p>重点说下slot我遇到的坑，在vue中使用slot使用是对slot进行具名匹配，slot中的dom作用域是父组件的作用域，slot中组件同时可以继续嵌套。</p><p>那再mpvue中是什么个样子呢。。。我只想说<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```javascript</span><br><span class="line">&lt;select-city</span><br><span class="line">  @onCityChange=&quot;onCityChange&quot;</span><br><span class="line">  :selectAddress=&quot;selectAddress&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;template slot=&quot;default&quot;&gt;</span><br><span class="line">    &lt;section class=&quot;pickSection&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;picker&quot;&gt;&#123;&#123;selectAddress || &apos;地区&apos;&#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;i-icon class=&quot;iconUnfold&quot; type=&quot;unfold&quot; /&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/select-city&gt;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">上面这块代码是mpvue中截取的，&lt;select-city/&gt;是个地址选择器组件，原先我要实现的功能是传个onCityChange方法进去并返回给我地址信息。</span><br><span class="line">然后将地址信息存到selectAddress变量里，再刷新到`&lt;div class=&quot;picker&quot;&gt;&#123;&#123;selectAddress || &apos;地区&apos;&#125;&#125;&lt;/div&gt;`这里，然而这么做了，然并卵</span><br></pre></td></tr></table></figure></p><p>最后查阅资料后我才知道，mpvue中的slot只能传静态数据，且需要对slot具名，slot嵌套无效，更尴尬的是，slot中的作用域竟然是在子组件里。<br>我有点蒙，然后就在父组件上传递了个<code>selectAddress</code>,然后才能获取地址信息。<br><strong>对于slot大家极力要求此功能完善下，目前为止还未实现</strong></p><blockquote><p>如果在小程序原生组件上例如map和canvas中使用v-if，mpvue在改变数据时会发现视图并未刷新。<br><strong>我采取的解决措施是将视图dom保留在文档流中，将组件定位到视图看不到的地方，符合条件再将之定位到需要的地方即可。</strong></p></blockquote><p>这里只阐述我遇到的坑~~~后续遇到将继续更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于未接触过&lt;code&gt;小程序&lt;/code&gt;的我来说，想起手做个小程序还是要费点时间去学习，但是&lt;code&gt;mpvue&lt;/code&gt;的出现让我提起了做小程序的兴趣。从而我的第一个小程序就这么从&lt;code&gt;mpvue&lt;/code&gt;中摸爬滚打中开始了&lt;/p&gt;
    
    </summary>
    
      <category term="mpvue" scheme="https://jiangjinjin1.github.io/categories/mpvue/"/>
    
    
      <category term="mpvue" scheme="https://jiangjinjin1.github.io/tags/mpvue/"/>
    
  </entry>
  
  <entry>
    <title>React高阶组件(HOC)入门</title>
    <link href="https://jiangjinjin1.github.io/2018/11/16/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-HOC-%E5%85%A5%E9%97%A8/"/>
    <id>https://jiangjinjin1.github.io/2018/11/16/React高阶组件-HOC-入门/</id>
    <published>2018-11-16T07:24:47.000Z</published>
    <updated>2018-11-29T05:45:22.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;之前的文章<a href="https://segmentfault.com/a/1190000008814336" target="_blank" rel="noopener">React Mixins入门指南</a>介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。<a href="https://twitter.com/dan_abramov" target="_blank" rel="noopener">Dan Abramov</a>在文章<a href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html" target="_blank" rel="noopener">Mixins Considered Harmful</a>介绍了Mixin带来的一些问题,总结下来主要是以下几点:</p></blockquote><a id="more"></a><ul><li><p>破坏组件封装性: Mixin可能会引入不可见的属性。例如在渲染组件中使用Mixin方法，给组件带来了不可见的属性(props)和状态(state)。并且Mixin可能会相互依赖，相互耦合，不利于代码维护。</p></li><li><p>不同的Mixin中的方法可能会相互冲突</p></li><li><p>为了处理上述的问题，React官方推荐使用高阶组件(High Order Component)</p></li></ul><h1 id="高阶组件-HOC"><a href="#高阶组件-HOC" class="headerlink" title="高阶组件(HOC)"></a>高阶组件(HOC)</h1><hr><p>  &nbsp;&nbsp;&nbsp;&nbsp;刚开始学习高阶组件时，这个概念就透漏着高级的气味，看上去就像是一种先进的编程技术的一个深奥术语，毕竟名字里就有”高阶”这种字眼，实质上并不是如此。高阶组件的概念应该是来源于JavaScript的高阶函数:</p><blockquote><p><code>高阶函数就是接受函数作为输入或者输出的函数</code></p></blockquote><p>  这么看来<a href="https://segmentfault.com/a/1190000008193605" target="_blank" rel="noopener">柯里化</a>也是高阶函数了。React官方定义高阶组件的概念是:</p><blockquote><p><code>A higher-order component is a function that takes a component and returns a new component.</code></p></blockquote><p>  &nbsp;&nbsp;&nbsp;&nbsp;(参照翻译了React官方文档的<a href="https://github.com/MrErHu/React-Advanced-Guides-CN" target="_blank" rel="noopener">Advanced Guides</a>部分，官方的高阶组件中文文档戳<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FMrErHu%2FReact-Advanced-Guides-CN%2Fblob%2Fmaster%2Fdoc%2FHigher%2520Order%2520Components.md" target="_blank" rel="noopener">这里</a>)</p><p>  &nbsp;&nbsp;&nbsp;&nbsp;这么看来，高阶组件仅仅只是是一个接受组件组作输入并返回组件的函数。看上去并没有什么，那么高阶组件能为我们带来什么呢？首先看一下高阶组件是如何实现的，通常情况下，实现高阶组件的方式有以下两种:</p><ol><li>属性代理(Props Proxy)</li><li>反向继承(Inheritance Inversion)</li></ol><h2 id="属性代理"><a href="#属性代理" class="headerlink" title="属性代理"></a>属性代理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;又是一个听起来很高大上的名词，实质上是通过包裹原来的组件来操作props，举个简单的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'React'</span>;</span><br><span class="line"><span class="comment">//高阶组件定义</span></span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//普通的组件</span><br><span class="line">class WrappedComponent extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//高阶组件使用</span><br><span class="line">export default HOC(WrappedComponent)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子非常简单，但足以说明问题。我们可以看见函数HOC返回了新的组件(WrapperComponent)，这个组件原封不动的返回作为参数的组件(也就是被包裹的组件:WrappedComponent)，并将传给它的参数(props)全部传递给被包裹的组件(WrappedComponent)。这么看起来好像并没有什么作用，其实属性代理的作用还是非常强大的。</p><h2 id="操作props"><a href="#操作props" class="headerlink" title="操作props"></a>操作props</h2><p>　　&nbsp;&nbsp;&nbsp;&nbsp;我们看到之前要传递给被包裹组件WrappedComponent的属性首先传递给了高阶组件返回的组件(WrapperComponent)，这样我们就获得了props的控制权(这也就是为什么这种方法叫做属性代理)。我们可以按照需要对传入的props进行增加、删除、修改(当然修改带来的风险需要你自己来控制)，举个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">                name: <span class="string">'HOC'</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent</span><br><span class="line">                &#123;...this.props&#125;</span><br><span class="line">                &#123;...newProps&#125;</span><br><span class="line">            /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。</p><h2 id="获得refs的引用"><a href="#获得refs的引用" class="headerlink" title="获得refs的引用"></a>获得<code>refs</code>的引用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(<code>ref</code>)，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'React'</span>;</span><br><span class="line">　</span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">wrapperComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        storeRef(ref) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ref = ref;</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent</span><br><span class="line">                &#123;...this.props&#125;</span><br><span class="line">                ref = &#123;::this.storeRef&#125;</span><br><span class="line">            /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。</p><h2 id="抽象state"><a href="#抽象state" class="headerlink" title="抽象state"></a>抽象state</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现不受控组件到受控的组件的转变(关于不受控组件和受控组件戳<a href="https://github.com/MrErHu/React-Advanced-Guides-CN/blob/master/doc/Uncontrolled%20Components.md" target="_blank" rel="noopener">这里</a>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;input name="name" &#123;...this.props.name&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const HOC = (WrappedComponent) =&gt;</span><br><span class="line">    class extends Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">            super(props);</span><br><span class="line">            this.state = &#123;</span><br><span class="line">                name: '',</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            this.onNameChange = this.onNameChange.bind(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onNameChange(event) &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                name: event.target.value,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            const newProps = &#123;</span><br><span class="line">                name: &#123;</span><br><span class="line">                    value: this.state.name,</span><br><span class="line">                    onChange: this.onNameChange,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件.</p><h2 id="用其他元素包裹组件"><a href="#用其他元素包裹组件" class="headerlink" title="用其他元素包裹组件"></a>用其他元素包裹组件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过类似:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式将被包裹组件包裹起来，来实现布局或者是样式的目的。<br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在属性代理这种方式实现的高阶组件，以上述为例，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序是先WrapperComponent再WrappedComponent(执行ComponentWillUnmount的时间)。</p><h2 id="反向继承"><a href="#反向继承" class="headerlink" title="反向继承"></a>反向继承</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:<code>super.render()</code>)，这也就是为什么叫做反向继承。</p><h2 id="渲染劫持"><a href="#渲染劫持" class="headerlink" title="渲染劫持"></a>渲染劫持</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.props.isRender) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;甚至我们可以修改修改render的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子来源于《深入React技术栈》</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HOC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render();</span><br><span class="line">            <span class="keyword">let</span> newProps = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (elementsTree &amp;&amp; elementsTree.type === <span class="string">'input'</span>) &#123;</span><br><span class="line">                newProps = &#123;<span class="attr">value</span>: <span class="string">'may the force be with you'</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, elementsTree.props, newProps);</span><br><span class="line">            <span class="keyword">const</span> newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);</span><br><span class="line">            <span class="keyword">return</span> newElementsTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;input value=&#123;<span class="string">'Hello World'</span>&#125; /&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HOC(WrappedComponent)</span><br><span class="line"><span class="comment">//实际显示的效果是input的值为"may the force be with you"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的例子中我们将WrappedComponent中的input元素value值修改为:<code>may the force be with you。</code>我们可以看到前后elementTree的区别:<br>elementsTree:</p><p><img src="/images/react/react1.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;newElementsTree:</p><p><img src="/images/react/react2.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;在反向继承中，我们可以做非常多的操作，修改state、props甚至是翻转Element Tree。反向继承有一个重要的点: <strong>反向继承不能保证完整的子组件树被解析</strong>，开始我对这个概念也不理解，后来在看了<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">React Components</a>, <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">Elements</a>, and <a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html" target="_blank" rel="noopener">Instances</a>这篇文章之后对这个概念有了自己的一点体会。React Components, Elements, and Instances这篇文章主要明确了一下几个点:</p><p>&nbsp;&nbsp;&nbsp;&nbsp; + 元素(element)是一个是用DOM节点或者组件来描述屏幕显示的纯对象，元素可以在属性(props.children)中包含其他的元素，一旦创建就不会改变。我们通过<code>JSX</code>和<code>React.createClass</code>创建的都是元素。<br>&nbsp;&nbsp;&nbsp;&nbsp; + 组件(component)可以接受属性(props)作为输入，然后返回一个元素树(element tree)作为输出。有多种实现方式:Class或者函数(Function)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;所以，<strong>反向继承不能保证完整的子组件树被解析</strong>的意思的解析的元素树中包含了组件(函数类型或者Class类型)，就不能再操作组件的子组件了，这就是所谓的<strong>不能完全解析</strong>。举个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyFuncComponent = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class MyClassComponent extends Component&#123;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    render()&#123;</span></span><br><span class="line"><span class="regexp">        return (</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;span&gt;Hello World&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">                &lt;MyFuncComponent /&gt;</span><br><span class="line">                &lt;MyClassComponent /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const HOC = (WrappedComponent) =&gt;</span></span><br><span class="line"><span class="regexp">    class extends WrappedComponent &#123;</span></span><br><span class="line"><span class="regexp">        render() &#123;</span></span><br><span class="line"><span class="regexp">            const elementsTree = super.render();</span></span><br><span class="line"><span class="regexp">            return elementsTree;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default HOC(WrappedComponent);</span></span><br></pre></td></tr></table></figure><p><img src="/images/react/react3.png"></p><p><img src="/images/react/react4.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以查看解析的元素树(element tree)，<code>div</code>下的<code>span</code>是可以被完全被解析的，但是<code>MyFuncComponent</code>和<code>MyClassComponent</code>都是组件类型的，其子组件就不能被完全解析了。</p><h2 id="操作props和state"><a href="#操作props和state" class="headerlink" title="操作props和state"></a>操作props和state</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在上面的图中我们可以看到，解析的元素树(element tree)中含有<code>props</code>和<code>state</code>(例子的组件中没有state),以及<code>ref</code>和<code>key</code>等值。因此，如果需要的话，我们不仅可以读取<code>props</code>和<code>state</code>,甚至可以修改增加、修改和删除。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，我们可能需要为高阶属性传入一些参数，那我们就可以通过柯里化的形式传入参数，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'React'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HOCFactoryFactory = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 可以做一些改变 params 的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">HOC</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;可以通过下面方式使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOCFactoryFactory(params)(WrappedComponent)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式是不是非常类似于<code>React-Redux</code>库中的<code>connect</code>函数，因为<code>connect</code>也是类似的一种高阶函数。反向继承不同于属性代理的调用顺序，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序也是先WrappedComponent再WrapperComponent(执行ComponentWillUnmount的时间)。</p><h2 id="HOC和Mixin的比较"><a href="#HOC和Mixin的比较" class="headerlink" title="HOC和Mixin的比较"></a>HOC和Mixin的比较</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;借用《深入React技术栈》一书中的图:</p><p><img src="/images/react/react5.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前的文章&lt;a href=&quot;https://segmentfault.com/a/1190000008814336&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Mixins入门指南&lt;/a&gt;介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。&lt;a href=&quot;https://twitter.com/dan_abramov&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dan Abramov&lt;/a&gt;在文章&lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mixins Considered Harmful&lt;/a&gt;介绍了Mixin带来的一些问题,总结下来主要是以下几点:&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="react" scheme="https://jiangjinjin1.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://jiangjinjin1.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>markdown基础语法</title>
    <link href="https://jiangjinjin1.github.io/2018/11/16/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://jiangjinjin1.github.io/2018/11/16/markdown基础语法/</id>
    <published>2018-11-16T05:59:03.000Z</published>
    <updated>2018-11-29T05:45:34.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-markdown是什么？"><a href="#1-markdown是什么？" class="headerlink" title="1. markdown是什么？"></a>1. markdown是什么？</h1><blockquote><p>Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。<br>Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。</p></blockquote><a id="more"></a><h1 id="2-markdown语法"><a href="#2-markdown语法" class="headerlink" title="2. markdown语法"></a>2. markdown语法</h1><h2 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h2><p>标题有两种形式：<br>(1) 第一种是用=或者-表示一级或者二级标题</p><blockquote><p>一级标题<br><code>======</code><br>二级标题<br><code>------</code></p></blockquote><p>效果如下：</p><blockquote><h1 id="一级标题down"><a href="#一级标题down" class="headerlink" title="一级标题down"></a>一级标题down</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>(2) 第二种就是#来表示1-6级标题，与HTML的h1-h6相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; #一级标题</span><br><span class="line">&gt; ##二级标题</span><br><span class="line">&gt; ###三级标题</span><br><span class="line">&gt; ####四级标题</span><br><span class="line">&gt; #####五级标题</span><br><span class="line">&gt; ######六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h2><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用，如：</p><blockquote><p>>引用<br>  >>嵌套引用</p></blockquote><p>效果如下：</p><blockquote><p>引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h2 id="2-3-代码块"><a href="#2-3-代码块" class="headerlink" title="2.3 代码块"></a>2.3 代码块</h2><p>代码块可以在每行加上四个空格来表示代码区域，效果如：</p><blockquote><p>   function foo(){<br>         return;<br>   }</p></blockquote><p>或者在开始与结尾用表示一样可以，效果同上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&gt; <span class="keyword">return</span>;</span><br><span class="line">&gt; &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-符号"><a href="#2-4-符号" class="headerlink" title="2.4 ``符号"></a>2.4 ``符号</h2><p>``可以用来表示相对较小区域的代码内容，或者起到标记作用，如</p><blockquote><p>`标记`</p></blockquote><p>效果如下：</p><blockquote><p><code>标记</code></p></blockquote><h2 id="2-5-强调与斜体"><a href="#2-5-强调与斜体" class="headerlink" title="2.5 强调与斜体"></a>2.5 强调与斜体</h2><p>在强调内容两侧分别加上*或者_，如：</p><blockquote><p>*斜体，_斜体_<br>**粗体**，__粗体__</p></blockquote><p>效果如下：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h2 id="2-6-有序列表与无序列表"><a href="#2-6-有序列表与无序列表" class="headerlink" title="2.6 有序列表与无序列表"></a>2.6 有序列表与无序列表</h2><p>使用*、+、或-标记无序列表，如：</p><blockquote><p>(+-) 第一项 (+-) 第二项<br>*(+-) 第三项</p></blockquote><p>效果如下：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>使用数字123加上.即是有序列表，如：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><p>效果如下：</p><blockquote><p>1.第一项<br>2.第二项<br>3.第三项</p></blockquote><h2 id="2-7-分割线"><a href="#2-7-分割线" class="headerlink" title="2.7 分割线"></a>2.7 分割线</h2><p>分割线最常使用就是三个或以上*，还可以使用-和_，如：</p><blockquote><p>我是分割线1<br>***<br>我是分割线2<br>———<br>我是分割线3<br>___</p></blockquote><p>效果如下：</p><p>我是分割线1</p><hr><h2 id="我是分割线2"><a href="#我是分割线2" class="headerlink" title="我是分割线2"></a>我是分割线2</h2><p>我是分割线3</p><hr><h2 id="2-8-链接"><a href="#2-8-链接" class="headerlink" title="2.8 链接"></a>2.8 链接</h2><p>链接由[]与()组成，[]中的指描述，()中跟链接地址，如：</p><blockquote><p>[百度](<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a>)</p></blockquote><p>效果如下：</p><blockquote><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a></p></blockquote><h2 id="2-9-图片引入"><a href="#2-9-图片引入" class="headerlink" title="2.9 图片引入"></a>2.9 图片引入</h2><blockquote><p>![图片](图片地址)</p></blockquote><p>效果如下</p><blockquote><p><img src="http://thirdwx.qlogo.cn/mmopen/vi_32/6h85RMsib6oGMKz0eibALsD1ricmicj6gUbUWAOs0C6Ynhf7Na6IBLyoWpHxTnHAZoAdznwicTf1Xaa61xdnEjV1QTg/132" alt="图片"></p></blockquote><p>2.9 表格<br>写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First Header | Second Header | Third Header</span><br><span class="line">------------ | ------------- | ------------</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br></pre></td></tr></table></figure><p>在 Markdown 中，可以制作表格，例如：</p><table><thead><tr><th>First Header</th><th>Second Header</th><th>Third Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-markdown是什么？&quot;&gt;&lt;a href=&quot;#1-markdown是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. markdown是什么？&quot;&gt;&lt;/a&gt;1. markdown是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。&lt;br&gt;Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具类" scheme="https://jiangjinjin1.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="https://jiangjinjin1.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>RSA加解密签名用法</title>
    <link href="https://jiangjinjin1.github.io/2017/08/11/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95/"/>
    <id>https://jiangjinjin1.github.io/2017/08/11/RSA加解密签名用法/</id>
    <published>2017-08-11T03:26:23.000Z</published>
    <updated>2018-11-29T05:45:30.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下<code>js</code>语言中， RSA加解密和签名加解密的实现。</p><a id="more"></a><p>分享两个库，都是用来加解密的，<a href="https://github.com/kjur/jsrsasign" target="_blank" rel="noopener">https://github.com/kjur/jsrsasign</a> <a href="https://github.com/travist/jsencrypt" target="_blank" rel="noopener">https://github.com/travist/jsencrypt</a><br>由于<code>jsrsasign</code>库加密业务数据总是出现报错，之后就用了<code>jsencrypt</code>来实现了业务数据的加密，再通过<code>jsrsasign</code>来实现签名以及签名校验</p><p><code>首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码，实现加解密要以下几个步骤：　　（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。　　（2）甲方获取乙方的公钥，然后用它对信息加密。　　（3）乙方得到加密后的信息，用私钥解密。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> encryptMethod = <span class="function">(<span class="params">bussinessParams: <span class="built_in">Object</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这部分是加密业务数据的方法</span></span><br><span class="line">    <span class="keyword">const</span> encrypt = <span class="keyword">new</span> JSEncrypt()</span><br><span class="line">    encrypt.setPublicKey(publicKey)</span><br><span class="line">    <span class="keyword">const</span> encrypted = encrypt.encrypt(<span class="built_in">encodeURIComponent</span>(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(bussinessParams)))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密后，原文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line">    <span class="comment">// 私钥解密</span></span><br><span class="line">    <span class="keyword">var</span> decrypt = <span class="keyword">new</span> JSEncrypt();</span><br><span class="line">    decrypt.setPrivateKey(privKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密密文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">var</span> uncrypted = decrypt.decrypt(encrypted);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"私钥解密后，原文 : "</span> + uncrypted);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面诉说的是业务数据的加密</p><p><code>我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名，签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sign = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sig = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig.init(privateKey)</span><br><span class="line">    sig.updateString(encrypted)<span class="comment">//此处encrypted是加密的业务数据</span></span><br><span class="line">    <span class="keyword">const</span> hSigVal = <span class="built_in">encodeURIComponent</span>(sig.sign())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sig1 = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig1.init(publicKey)<span class="comment">//此处需要公钥去对签名进行校验</span></span><br><span class="line">    sig1.updateString(encrypted)</span><br><span class="line">    <span class="keyword">const</span> verified = sig1.verify(hSigVal)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"签名校验后结果 : "</span> + verified);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是签名的api文档：<a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html</a><br>签名校验的demo：<a href="https://kjur.github.io/jsrsasign/sample/sample-rsasign.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/sample/sample-rsasign.html</a><br>命令生成密钥文档：<a href="http://www.cnblogs.com/littleatp/p/5878763.html" target="_blank" rel="noopener">http://www.cnblogs.com/littleatp/p/5878763.html</a></p><p><code>JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能</code></p><p>分段加密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The right encryption code</span></span><br><span class="line">JSEncrypt.prototype.encryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = (((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>)<span class="number">-11</span>);<span class="comment">//此处是算法来算出你的密钥可以支持的最大加密字符串长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lt = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      lt = string.match(<span class="regexp">/.&#123;1,117&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.encrypt(entry);</span><br><span class="line">        ct += t1 ;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> hex2b64(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t = k.encrypt(string);</span><br><span class="line">    <span class="keyword">var</span> y = hex2b64(t);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>分段解密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error decryption code</span></span><br><span class="line">JSEncrypt.prototype.decryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = ((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> string = b64tohex(string);</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      <span class="keyword">var</span> lt = string.match(<span class="regexp">/.&#123;1,128&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.decrypt(entry);</span><br><span class="line">        ct += t1;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y = k.decrypt(b64tohex(string));</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此篇文章只是个人在使用这两个库中的使用的感受，<code>jsencrypt</code>可以加解密但是不存在签名方法， <code>jsrsasign</code>可以签名，但是使用过程中加密方法报错。<br>初次写文章，不到之处还请轻喷！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下&lt;code&gt;js&lt;/code&gt;语言中， RSA加解密和签名加解密的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="工具类" scheme="https://jiangjinjin1.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="工具类" scheme="https://jiangjinjin1.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>理解applyMiddleware和createStore之间的关系</title>
    <link href="https://jiangjinjin1.github.io/2017/08/01/%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://jiangjinjin1.github.io/2017/08/01/理解redux中的applyMiddleware与中间件/</id>
    <published>2017-08-01T03:26:23.000Z</published>
    <updated>2018-11-29T05:45:27.620Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不得不佩服redux的作者<code>Dan Abramov</code>，看完<code>applyMiddleware</code>的源码,我的感受就是：还有这种操作？<br>与其说是理解applyMiddleware，不如说是理清<code>createStore</code>，<code>applyMiddleware</code>和一些中间件的关系，和为什么中间件都是<code>export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}</code>三层嵌套关系。  </p><a id="more"></a><pre><code class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>{  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) {    middlewares[_key] = <span class="built_in">arguments</span>[_key];  }  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);      <span class="keyword">var</span> _dispatch = store.dispatch;      <span class="keyword">var</span> chain = [];      <span class="keyword">var</span> middlewareAPI = {        <span class="attr">getState</span>: store.getState,        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>{          <span class="keyword">return</span> _dispatch(action);        }      };      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>{        <span class="keyword">return</span> middleware(middlewareAPI);      });      _dispatch = compose.apply(<span class="literal">undefined</span>, chain)(store.dispatch);      <span class="keyword">return</span> _extends({}, store, {        <span class="attr">dispatch</span>: _dispatch      });    };  };}</code></pre><p>精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：<br><img src="/images/createStore1.png"><br>enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数<br><img src="/images/applyMiddleware1.png"><br>两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）：  </p><p><code>首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。</code>  </p><pre><code class="javascript"><span class="keyword">const</span> store = createStore(    reducer,    <span class="literal">undefined</span>,    enhancer  )</code></pre><p><code>其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。</code>  </p><pre><code class="javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) {    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) {      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);    }    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);  }</code></pre><p><code>最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。</code></p><pre><code class="javascript"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);    <span class="comment">//省略一万行</span>  }}</code></pre><p>至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。<br><img src="/images/applyMiddleware2.png"></p><h4 id="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"><a href="#菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。" class="headerlink" title="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"></a>菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</h4><p>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不得不佩服redux的作者&lt;code&gt;Dan Abramov&lt;/code&gt;，看完&lt;code&gt;applyMiddleware&lt;/code&gt;的源码,我的感受就是：还有这种操作？&lt;br&gt;与其说是理解applyMiddleware，不如说是理清&lt;code&gt;createStore&lt;/code&gt;，&lt;code&gt;applyMiddleware&lt;/code&gt;和一些中间件的关系，和为什么中间件都是&lt;code&gt;export const createThunkMiddleware = ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt; {...}&lt;/code&gt;三层嵌套关系。  &lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="https://jiangjinjin1.github.io/categories/react/"/>
    
      <category term="redux" scheme="https://jiangjinjin1.github.io/categories/react/redux/"/>
    
    
      <category term="react" scheme="https://jiangjinjin1.github.io/tags/react/"/>
    
  </entry>
  
</feed>
