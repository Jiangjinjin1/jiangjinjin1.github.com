<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fighting of erha</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiangjinjin1.github.io/"/>
  <updated>2018-11-15T09:27:37.342Z</updated>
  <id>https://jiangjinjin1.github.io/</id>
  
  <author>
    <name>fighting of erha</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RSA加解密签名用法</title>
    <link href="https://jiangjinjin1.github.io/2017/08/11/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%AD%BE%E5%90%8D%E7%94%A8%E6%B3%95/"/>
    <id>https://jiangjinjin1.github.io/2017/08/11/RSA加解密签名用法/</id>
    <published>2017-08-11T03:26:23.000Z</published>
    <updated>2018-11-15T09:27:37.342Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下<code>js</code>语言中， RSA加解密和签名加解密的实现。</p><a id="more"></a><p>分享两个库，都是用来加解密的，<a href="https://github.com/kjur/jsrsasign" target="_blank" rel="noopener">https://github.com/kjur/jsrsasign</a> <a href="https://github.com/travist/jsencrypt" target="_blank" rel="noopener">https://github.com/travist/jsencrypt</a><br>由于<code>jsrsasign</code>库加密业务数据总是出现报错，之后就用了<code>jsencrypt</code>来实现了业务数据的加密，再通过<code>jsrsasign</code>来实现签名以及签名校验</p><p><code>首先我们要知道加密解密的实现，要明白怎么去加密，又怎么去解密，这个地方就要求我们知道非对称密钥对的概念，什么是密钥对，就是双方之间互相提供公钥来实现加密解密用的密码，实现加解密要以下几个步骤：　　（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。　　（2）甲方获取乙方的公钥，然后用它对信息加密。　　（3）乙方得到加密后的信息，用私钥解密。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> encryptMethod = <span class="function">(<span class="params">bussinessParams: <span class="built_in">Object</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//这部分是加密业务数据的方法</span></span><br><span class="line">    <span class="keyword">const</span> encrypt = <span class="keyword">new</span> JSEncrypt()</span><br><span class="line">    encrypt.setPublicKey(publicKey)</span><br><span class="line">    <span class="keyword">const</span> encrypted = encrypt.encrypt(<span class="built_in">encodeURIComponent</span>(</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(bussinessParams)))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密后，原文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line">    <span class="comment">// 私钥解密</span></span><br><span class="line">    <span class="keyword">var</span> decrypt = <span class="keyword">new</span> JSEncrypt();</span><br><span class="line">    decrypt.setPrivateKey(privKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"公钥加密密文 : "</span> + encrypted);</span><br><span class="line">    <span class="keyword">var</span> uncrypted = decrypt.decrypt(encrypted);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"私钥解密后，原文 : "</span> + uncrypted);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面诉说的是业务数据的加密</p><p><code>我们加密完业务数据信息还想要一种东西来验证我的业务数据是否被串改，这个时候就需要签名的方法来实现验证是否串改信息，签名是需要拿己方私钥对加密过的业务数据进行签名，签完名之后把加密数据和签名串都传给对方，对方用己方提供的公钥进行签名的校验，直接上代码</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sign = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> sig = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig.init(privateKey)</span><br><span class="line">    sig.updateString(encrypted)<span class="comment">//此处encrypted是加密的业务数据</span></span><br><span class="line">    <span class="keyword">const</span> hSigVal = <span class="built_in">encodeURIComponent</span>(sig.sign())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sig1 = <span class="keyword">new</span> KJUR.crypto.Signature(&#123; <span class="attr">alg</span>: <span class="string">'SHA1withRSA'</span> &#125;)</span><br><span class="line">    sig1.init(publicKey)<span class="comment">//此处需要公钥去对签名进行校验</span></span><br><span class="line">    sig1.updateString(encrypted)</span><br><span class="line">    <span class="keyword">const</span> verified = sig1.verify(hSigVal)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"签名校验后结果 : "</span> + verified);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    Alert.alert(<span class="string">`RSA <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是签名的api文档：<a href="https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/api/symbols/KJUR.crypto.Signature.html</a><br>签名校验的demo：<a href="https://kjur.github.io/jsrsasign/sample/sample-rsasign.html" target="_blank" rel="noopener">https://kjur.github.io/jsrsasign/sample/sample-rsasign.html</a><br>命令生成密钥文档：<a href="http://www.cnblogs.com/littleatp/p/5878763.html" target="_blank" rel="noopener">http://www.cnblogs.com/littleatp/p/5878763.html</a></p><p><code>JavaScript RSA 超长字符加解密刚刚接触到RSA当时不了解，RSA加解密是有字符串长度限制的，加密最大字符长度是117位，解密最大长度是128位。用到的JS库JSEncrypt,刚开始找了好几个,发现就这个好用一些,换回来了(途中遇到很多坑，一步一个坑过来的)。这个库的缺陷：没法用公钥解密只能加密，私钥没法加密只能</code></p><p>分段加密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The right encryption code</span></span><br><span class="line">JSEncrypt.prototype.encryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = (((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>)<span class="number">-11</span>);<span class="comment">//此处是算法来算出你的密钥可以支持的最大加密字符串长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lt = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      lt = string.match(<span class="regexp">/.&#123;1,117&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.encrypt(entry);</span><br><span class="line">        ct += t1 ;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> hex2b64(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t = k.encrypt(string);</span><br><span class="line">    <span class="keyword">var</span> y = hex2b64(t);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>分段解密方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The error decryption code</span></span><br><span class="line">JSEncrypt.prototype.decryptLong = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> k = <span class="keyword">this</span>.getKey();</span><br><span class="line">  <span class="keyword">var</span> maxLength = ((k.n.bitLength()+<span class="number">7</span>)&gt;&gt;<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> string = b64tohex(string);</span><br><span class="line">    <span class="keyword">var</span> ct = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; maxLength) &#123;</span><br><span class="line">      <span class="keyword">var</span> lt = string.match(<span class="regexp">/.&#123;1,128&#125;/g</span>);</span><br><span class="line">      lt.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t1 = k.decrypt(entry);</span><br><span class="line">        ct += t1;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y = k.decrypt(b64tohex(string));</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>此篇文章只是个人在使用这两个库中的使用的感受，<code>jsencrypt</code>可以加解密但是不存在签名方法， <code>jsrsasign</code>可以签名，但是使用过程中加密方法报错。<br>初次写文章，不到之处还请轻喷！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;非对称加密技术是保证我们信息安全非常重要的技术。 RSA便是其中翘楚， 应用广泛。本文仅从实用的角度， 总结一下&lt;code&gt;js&lt;/code&gt;语言中， RSA加解密和签名加解密的实现。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解applyMiddleware和createStore之间的关系</title>
    <link href="https://jiangjinjin1.github.io/2017/08/01/%E7%90%86%E8%A7%A3redux%E4%B8%AD%E7%9A%84applyMiddleware%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://jiangjinjin1.github.io/2017/08/01/理解redux中的applyMiddleware与中间件/</id>
    <published>2017-08-01T03:26:23.000Z</published>
    <updated>2018-11-15T09:27:40.671Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>不得不佩服redux的作者<code>Dan Abramov</code>，看完<code>applyMiddleware</code>的源码,我的感受就是：还有这种操作？<br>与其说是理解applyMiddleware，不如说是理清<code>createStore</code>，<code>applyMiddleware</code>和一些中间件的关系，和为什么中间件都是<code>export const createThunkMiddleware = ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {...}</code>三层嵌套关系。  </p><a id="more"></a><pre><code class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>{  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) {    middlewares[_key] = <span class="built_in">arguments</span>[_key];  }  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);      <span class="keyword">var</span> _dispatch = store.dispatch;      <span class="keyword">var</span> chain = [];      <span class="keyword">var</span> middlewareAPI = {        <span class="attr">getState</span>: store.getState,        <span class="attr">dispatch</span>: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>{          <span class="keyword">return</span> _dispatch(action);        }      };      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>{        <span class="keyword">return</span> middleware(middlewareAPI);      });      _dispatch = compose.apply(<span class="literal">undefined</span>, chain)(store.dispatch);      <span class="keyword">return</span> _extends({}, store, {        <span class="attr">dispatch</span>: _dispatch      });    };  };}</code></pre><p>精简的30行代码，设计思想强无敌。不难看出applyMiddleware这个函数接收一个createStore函数返回一个接收参数和createStore一样的函数。如下图是createStore的部分源码：<br><img src="/images/createStore1.png"><br>enhancer就是applyMiddleware执行完第一层后的函数，传一个createStore函数，再次返回一个函数，但此时只传外层的reducer和preloadedState，却没在传第三个enhancer参数。这里要看回到applyMiddleware函数<br><img src="/images/applyMiddleware1.png"><br>两层形参对应上面的实参，可以看到applyMiddleware内部还调用了createStore，整个一个完整的逻辑如下（部分重要代码）：  </p><p><code>首先是调用createStore，这个enhancer其实就是applyMiddleware(middleware1, middleware2)。</code>  </p><pre><code class="javascript"><span class="keyword">const</span> store = createStore(    reducer,    <span class="literal">undefined</span>,    enhancer  )</code></pre><p><code>其次是createStore里判断执行enhancer，如果传了enhancer，那就对enhancer执行再执行，且第二次执行不传enhancer，这里return的其实也是applyMiddleware函数的返回值，但是等下在applyMiddleware里还会在执行一次createStore。</code>  </p><pre><code class="javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) {    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) {      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);    }    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);  }</code></pre><p><code>最后是applyMiddleware里的，由于createStore上面最后一次执行未传enhancer，所以applyMiddleware里的createStore是不会再次执行enhancer,不然就死循环了。拿到返回的sotre对象，重新改造dispatch并返回，这就是中间件的实现的一个大体流程。</code></p><pre><code class="javascript"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>{  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>{    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);    <span class="comment">//省略一万行</span>  }}</code></pre><p>至此，相信大家也差不多理解了createStore和applyMiddleware相互之间的关系了，其实关于中间件为什么嵌套三层的问题也自然而然的解开了，一张图片来说明吧。<br><img src="/images/applyMiddleware2.png"></p><h4 id="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"><a href="#菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。" class="headerlink" title="菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。"></a>菜鸟学习笔记，如有不对，还希望高手指点。如有造成误解，还希望多多谅解。</h4><p>著作权归作者所有。<br>商业转载请联系作者获得授权,非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;不得不佩服redux的作者&lt;code&gt;Dan Abramov&lt;/code&gt;，看完&lt;code&gt;applyMiddleware&lt;/code&gt;的源码,我的感受就是：还有这种操作？&lt;br&gt;与其说是理解applyMiddleware，不如说是理清&lt;code&gt;createStore&lt;/code&gt;，&lt;code&gt;applyMiddleware&lt;/code&gt;和一些中间件的关系，和为什么中间件都是&lt;code&gt;export const createThunkMiddleware = ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt; {...}&lt;/code&gt;三层嵌套关系。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
